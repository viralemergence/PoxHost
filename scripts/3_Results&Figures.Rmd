---
title: "Orthopoxvirus Link Prediction Model Code"
author: "Katie Tseng, Dan Becker, Colin Carlson, Pilar Fernandez, and Stephanie Seifert"
output:
  pdf_document:
  latex_engine: xelatex
  toc: yes
html_document:
  fig_height: 6
  fig_width: 6
  highlight: tango
  theme: journal
editor_options: 
  chunk_output_type: console
---

Introduction
============

The following code reproduces the analyses from *Viral genomic features predict orthopoxvirus reservoir hosts*, pertaining to the output from our BRT models which include our:

HOST TRAIT MODEL trained separately on two evidence levels for host capacity (i.e., host exposure via PCR positivity and host susceptibility via virus isolation) using host ecological traits alone to predict host positivity for OPVs (a group of viruses)

vs.

LINK PREDICTION MODELS trained on explicit pairing of host-virus associations using a combination of host and virus features to predict the existence of a host-virus link (i.e., compatibility). 

In total, five BRT models were run:
(1) Host exposure model
(2) Host susceptibility model
(3) Link prediction model (trained on host and viral traits)
(4) Link prediction model excluding vaccinia/VACV links (trained on host and viral traits)
(5) Link prediction model trained on host traits only

Before running the following script, download the following data files to your working directory: 
- *~/data/OPVnew_nowwithVirus.xlsx*: table of OPV genome annotations extracted from NCBI with corresponding accessory gene data (binary matrix)
- *OPV_6Jan23.nexus*: the nexus file of viral tree data for visualizing clustering of OPV sequences on the phylogenetic tree
    - This file is only needed in part one for hierarchical cluster analysis (optional): *Dimension Reduction* {r dim_tree}
- *~/data/hosttrait_cleandata.RData*: the clean data file for the host trait models
- *~/data/linkpred_cleandata.RData*: the clean data file for the link prediction models
- *MAMMALS.shp*: the shape file of mammal geographical range  
    - Obtained[IUCN Red List Spatial Database][1]  
    - This file (>1GB) is only required in part six: *Mapping Host Distribution*  

[1]: <https://www.iucnredlist.org/resources/spatial-data-download> "Spatial data download"


Table of Contents
=================

1. Model Performance {r perf}

2. Model Predictions {r pred}

3. Mapping Host Distribution {r map}

4. Feature Importance

5. PCA Figures

### *Before proceeding, we recommend setting knit options* and your working directory**

```{r knitr}

knitr::opts_chunk$set(eval=F)

```


1. Model Performance
====================

### Load required packages and set system

```{r perf_load, echo=FALSE}

#(1) Libraries for BRT figures
library(pROC)
library(InformationValue)
library(tidyr)
library(ggplot2)
library(sciplot)
library(fastDummies)
library(caper) #pgls, comparative.data
library(ape)
library(phylofactor)
library(plotrix) #std.error
library(rstatix)
library(ggrepel)
library(ggpubr)
library(plyr)
library(treeio)
library(ggtree)
library(viridis) #library for color palette

#(2) Clean environment
rm(list=ls()) 
graphics.off()

#(3) Set working directory
setwd("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost")

```


### *Evaluate performance measures for each independent BRT model
How accurately did the different models distinguish host-virus links from non-links (assuming a threshold value of 0.5)? We evaluate the mean AUC, sensitivity, and specificity of each of our independent models.

```{r perf_auc}

#### If needed, increase vector memory in R environment and reboot R before proceeding (https://stackoverflow.com/questions/51295402/r-on-macos-error-vector-memory-exhausted-limit-reached)

### LOAD DATA ###

# host exposure model - based on PCR data and host traits only
pcr_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/pcr_brts.rds") 

# host susceptibility model - based on virus isolation or 'competence' data and host traits only
comp_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/comp_brts.rds")

# pubmed/cites model - did traits predict citation counts? no, mean AUC = 0.50 (no better than chance)
pm_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/pm_brts.rds")
mean(sapply(pm_brts,function(x) x$testAUC))
std.error(sapply(pm_brts,function(x) x$testAUC))

# link prediction model 1 - including VACV links
load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model1/brts_Model1.RData")
brts1=brts
mean(sapply(pm_brts,function(x) x$testAUC)) # did traits predict citation counts? no, mean AUC = 0.50 
std.error(sapply(pm_brts,function(x) x$testAUC))
rm(brts, pm_brts)

# link prediction model 2 - excluding VACV links
load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model2/brts_Model2.RData")
brts2=brts
mean(sapply(pm_brts,function(x) x$testAUC)) # did traits predict citation counts? no, mean AUC = 0.50 
std.error(sapply(pm_brts,function(x) x$testAUC))
rm(brts, pm_brts)

# link prediction model 3 - including VACV links and host traits only (excludes viral/PC variables)
load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model3/brts_Model3.RData")
brts3=brts
mean(sapply(pm_brts,function(x) x$testAUC)) # did traits predict citation counts? no, mean AUC = 0.50 
std.error(sapply(pm_brts,function(x) x$testAUC))
rm(brts, pm_brts)

# Check number of iterations (should be 100)
length(pcr_brts)
length(comp_brts)
length(brts1)
length(brts2)
length(brts3)

# Index non-missing
pcr_keep=which(!is.na(sapply(pcr_brts,function(x) x$testAUC)))
comp_keep=which(!is.na(sapply(comp_brts,function(x) x$testAUC)))
keep1=which(!is.na(sapply(brts1,function(x) x$testAUC)))
keep2=which(!is.na(sapply(brts2,function(x) x$testAUC)))
keep3=which(!is.na(sapply(brts3,function(x) x$testAUC)))

# Trim, keeping only those that are non-missing
pcr_brts=pcr_brts[pcr_keep]
comp_brts=comp_brts[comp_keep]
brts1=brts1[keep1]
brts2=brts2[keep2]
brts3=brts3[keep3]

### GET PREDICTED PROBABILITIES FOR EACH ITERATION ### 

pcr_cpreds=lapply(pcr_brts,function(x) x$predict)
pcr_cpreds=lapply(pcr_cpreds,function(x) select(x,c("pcr","cpred")))

comp_cpreds=lapply(comp_brts,function(x) x$predict)
comp_cpreds=lapply(comp_cpreds,function(x) select(x,c("competence","cpred")))

m1_cpreds=lapply(brts1,function(x) x$predict)
m1_cpreds=lapply(m1_cpreds,function(x) select(x,c("link","cpred")))

m2_cpreds=lapply(brts2,function(x) x$predict)
m2_cpreds=lapply(m2_cpreds,function(x) select(x,c("link","cpred")))

m3_cpreds=lapply(brts3,function(x) x$predict)
m3_cpreds=lapply(m3_cpreds,function(x) select(x,c("link","cpred")))

### GET AUC FOR EACH ITERATION ### 

# Calculate mean AUC and SE across iterations (threshold value = 0.5)
pcr_auc = lapply(pcr_cpreds, function(x) pROC::auc(x$pcr, x$cpred))
mean = mean(sapply(pcr_auc,function(x) x))
se = std.error(sapply(pcr_auc,function(x) x))
pcr_auc_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

comp_auc = lapply(comp_cpreds, function(x) pROC::auc(x$comp, x$cpred))
mean = mean(sapply(comp_auc,function(x) x))
se = std.error(sapply(comp_auc,function(x) x))
comp_auc_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

m1_auc = lapply(m1_cpreds, function(x) pROC::auc(x$link, x$cpred))
mean = mean(sapply(m1_auc,function(x) x))
se = std.error(sapply(m1_auc,function(x) x))
m1_auc_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m2_auc = lapply(m2_cpreds, function(x) pROC::auc(x$link, x$cpred))
mean = mean(sapply(m2_auc,function(x) x))
se = std.error(sapply(m2_auc,function(x) x))
m2_auc_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m3_auc = lapply(m3_cpreds, function(x) pROC::auc(x$link, x$cpred))
mean = mean(sapply(m3_auc,function(x) x))
se = std.error(sapply(m3_auc,function(x) x))
m3_auc_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

### GET SENSITIVITY FOR EACH ITERATION ### 

# Calculate mean sensitivity and SE across iterations (threshold value = 0.5)
pcr_sens = lapply(pcr_cpreds, function(x) InformationValue::sensitivity(x$pcr, x$cpred, threshold=0.5))
mean = mean(sapply(pcr_sens,function(x) x))
se = std.error(sapply(pcr_sens,function(x) x))
pcr_sens_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

comp_sens = lapply(comp_cpreds, function(x) InformationValue::sensitivity(x$comp, x$cpred, threshold=0.5))
mean = mean(sapply(comp_sens,function(x) x))
se = std.error(sapply(comp_sens,function(x) x))
comp_sens_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

m1_sens = lapply(m1_cpreds, function(x) InformationValue::sensitivity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m1_sens,function(x) x))
se = std.error(sapply(m1_sens,function(x) x))
m1_sens_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m2_sens = lapply(m2_cpreds, function(x) InformationValue::sensitivity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m2_sens,function(x) x))
se = std.error(sapply(m2_sens,function(x) x))
m2_sens_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m3_sens = lapply(m3_cpreds, function(x) InformationValue::sensitivity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m3_sens,function(x) x))
se = std.error(sapply(m3_sens,function(x) x))
m3_sens_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

### GET SPECIFICITY FOR EACH ITERATION ### 

# Calculate mean specificity and SE across iterations (threshold value = 0.5)
pcr_spec = lapply(pcr_cpreds, function(x) InformationValue::specificity(x$pcr, x$cpred, threshold=0.5))
mean = mean(sapply(pcr_spec,function(x) x))
se = std.error(sapply(pcr_spec,function(x) x))
pcr_spec_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

comp_spec = lapply(comp_cpreds, function(x) InformationValue::specificity(x$comp, x$cpred, threshold=0.5))
mean = mean(sapply(comp_spec,function(x) x))
se = std.error(sapply(comp_spec,function(x) x))
comp_spec_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", formatC(se, format="e"))

m1_spec = lapply(m1_cpreds, function(x) InformationValue::specificity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m1_spec,function(x) x))
se = std.error(sapply(m1_spec,function(x) x))
m1_spec_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m2_spec = lapply(m2_cpreds, function(x) InformationValue::specificity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m2_spec,function(x) x))
se = std.error(sapply(m2_spec,function(x) x))
m2_spec_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

m3_spec = lapply(m3_cpreds, function(x) InformationValue::specificity(x$link, x$cpred, threshold=0.5))
mean = mean(sapply(m3_spec,function(x) x))
se = std.error(sapply(m3_spec,function(x) x))
m3_spec_mean <- paste0(sprintf("%.4f",mean), " \u00b1 ", sprintf("%.5f",se))

# Clean environment; save performance metrics to create a table in the next section
rm(pcr_cpreds, comp_cpreds, m1_cpreds, m2_cpreds, m3_cpreds, pcr_keep, comp_keep, keep1, keep2, keep3, mean, se)

```

### *Compare performance between BRTs w/ unpaired t-test and Cohen's d
We create a function to perform an unpaired T-test on the AUC, sensitivity and specificity of the models and determine the effect size (mean difference) via Cohen's d - e.g., Is model performance significantly different when trained on all links vs. links excluding VACV (link prediction model 1 vs. 2)?

```{r perf_compare}

### T-TEST FOR AUC ###

# get auc values
adata_pcr=data.frame(y=c(sapply(pcr_auc, function(x) x)))
adata_pcr$seed = 1:nrow(adata_pcr)
adata_pcr$response = "exposure"

adata_comp=data.frame(y=c(sapply(comp_auc, function(x) x)))
adata_comp$seed = 1:nrow(adata_comp)
adata_comp$response = "susceptibility"

adata_m1=data.frame(y=c(sapply(m1_auc, function(x) x)))
adata_m1$seed = 1:nrow(adata_m1)
adata_m1$response = "model1"

adata_m2=data.frame(y=c(sapply(m2_auc, function(x) x)))
adata_m2$seed = 1:nrow(adata_m2)
adata_m2$response = "model2"

adata_m3=data.frame(y=c(sapply(m3_auc, function(x) x)))
adata_m3$seed = 1:nrow(adata_m3)
adata_m3$response = "model3"

# combine auc values for all models: will need this for later {r perf_boxplot}
adata_auc_all = rbind(adata_pcr, adata_comp, adata_m1, adata_m2, adata_m3)

# t-test for pcr model vs. comp model
adata_auc = rbind(adata_pcr, adata_comp)
adata_auc$response=factor(adata_auc$response,levels=c('exposure','susceptibility'))
tsum_auc_pcrcomp=t.test(y~response,data=adata_auc,alternative='two.sided',var.equal=F,paired=F)  
csum_auc_pcrcomp=cohens_d(y~response,data=adata_auc,paired=F,var.equal=F)

# t-test for model 1 vs. model 2 (including vs. excluding VACV links)
adata_auc=rbind(adata_m1, adata_m2)
adata_auc$response=factor(adata_auc$response,levels=c('model1','model2'))
tsum_auc12=t.test(y~response,data=adata_auc,alternative='two.sided',var.equal=F,paired=F)  
csum_auc12=cohens_d(y~response,data=adata_auc,paired=F,var.equal=F)

# t-test for model 1 vs. model 3 (trained on host & virus traits vs. trained on host traits only)
adata_auc=rbind(adata_m1, adata_m3)
adata_auc$response=factor(adata_auc$response,levels=c('model1','model3'))
tsum_auc13=t.test(y~response,data=adata_auc,alternative='two.sided',var.equal=F,paired=F)  
csum_auc13=cohens_d(y~response,data=adata_auc,paired=F,var.equal=F)

# t-test for pcr model vs. model 3 
adata_auc=rbind(adata_pcr, adata_m3)
adata_auc$response=factor(adata_auc$response,levels=c('exposure','model3'))
tsum_auc_pcr3=t.test(y~response,data=adata_auc,alternative='two.sided',var.equal=F,paired=F)  
csum_auc_pcr3=cohens_d(y~response,data=adata_auc,paired=F,var.equal=F)

### T-TEST for Sensitivity ###

# get sensitivity values
adata_pcr=data.frame(y=c(sapply(pcr_sens, function(x) x)))
adata_pcr$seed = 1:nrow(adata_pcr)
adata_pcr$response = "exposure"

adata_comp=data.frame(y=c(sapply(comp_sens, function(x) x)))
adata_comp$seed = 1:nrow(adata_comp)
adata_comp$response = "susceptibility"

adata_m1=data.frame(y=c(sapply(m1_sens, function(x) x)))
adata_m1$seed = 1:nrow(adata_m1)
adata_m1$response = "model1"

adata_m2=data.frame(y=c(sapply(m2_sens, function(x) x)))
adata_m2$seed = 1:nrow(adata_m2)
adata_m2$response = "model2"

adata_m3=data.frame(y=c(sapply(m3_sens, function(x) x)))
adata_m3$seed = 1:nrow(adata_m3)
adata_m3$response = "model3"

# combine sensitivity values for all models: will need this for later {r perf_boxplot}
adata_sens_all = rbind(adata_pcr, adata_comp, adata_m1, adata_m2, adata_m3)

# t-test for pcr model vs. comp model
adata_sens = rbind(adata_pcr, adata_comp)
adata_sens$response=factor(adata_sens$response,levels=c('exposure','susceptibility'))
tsum_sens_pcrcomp=t.test(y~response,data=adata_sens,alternative='two.sided',var.equal=F,paired=F)  
csum_sens_pcrcomp=cohens_d(y~response,data=adata_sens,paired=F,var.equal=F)

# t-test for model 1 vs. model 2 (including vs. excluding VACV links)
adata_sens=rbind(adata_m1, adata_m2)
adata_sens$response=factor(adata_sens$response,levels=c('model1','model2'))
tsum_sens12=t.test(y~response,data=adata_sens,alternative='two.sided',var.equal=F,paired=F)  
csum_sens12=cohens_d(y~response,data=adata_sens,paired=F,var.equal=F)

# t-test for model 1 vs. model 3 (trained on host & virus traits vs. trained on host traits only)
adata_sens=rbind(adata_m1, adata_m3)
adata_sens$response=factor(adata_sens$response,levels=c('model1','model3'))
tsum_sens13=t.test(y~response,data=adata_sens,alternative='two.sided',var.equal=F,paired=F)  
csum_sens13=cohens_d(y~response,data=adata_sens,paired=F,var.equal=F)

# t-test for pcr model vs. model 3 
adata_sens=rbind(adata_pcr, adata_m3)
adata_sens$response=factor(adata_sens$response,levels=c('exposure','model3'))
tsum_sens_pcr3=t.test(y~response,data=adata_sens,alternative='two.sided',var.equal=F,paired=F)  
csum_sens_pcr3=cohens_d(y~response,data=adata_sens,paired=F,var.equal=F)

### T-TEST for Specificity ###

# get specificity values
adata_pcr=data.frame(y=c(sapply(pcr_spec, function(x) x)))
adata_pcr$seed = 1:nrow(adata_pcr)
adata_pcr$response = "exposure"

adata_comp=data.frame(y=c(sapply(comp_spec, function(x) x)))
adata_comp$seed = 1:nrow(adata_comp)
adata_comp$response = "susceptibility"

adata_m1=data.frame(y=c(sapply(m1_spec, function(x) x)))
adata_m1$seed = 1:nrow(adata_m1)
adata_m1$response = "model1"

adata_m2=data.frame(y=c(sapply(m2_spec, function(x) x)))
adata_m2$seed = 1:nrow(adata_m2)
adata_m2$response = "model2"

adata_m3=data.frame(y=c(sapply(m3_spec, function(x) x)))
adata_m3$seed = 1:nrow(adata_m3)
adata_m3$response = "model3"

# combine specificity values for all models: will need this {r perf_boxplot}
adata_spec_all = rbind(adata_pcr, adata_comp, adata_m1, adata_m2, adata_m3)

# t-test for pcr model vs. comp model
adata_spec = rbind(adata_pcr, adata_comp)
adata_spec$response=factor(adata_spec$response,levels=c('exposure','susceptibility'))
tsum_spec_pcrcomp=t.test(y~response,data=adata_spec,alternative='two.sided',var.equal=F,paired=F)  
csum_spec_pcrcomp=cohens_d(y~response,data=adata_spec,paired=F,var.equal=F)

# t-test for model 1 vs. model 2 (including vs. excluding VACV links)
adata_spec=rbind(adata_m1, adata_m2)
adata_spec$response=factor(adata_spec$response,levels=c('model1', 'model2'))
tsum_spec12=t.test(y~response,data=adata_spec,alternative='two.sided',var.equal=F,paired=F)  
csum_spec12=cohens_d(y~response,data=adata_spec,paired=F,var.equal=F)

# t-test for model 1 vs. model 3 (trained on host & virus traits vs. trained on host traits only)
adata_spec=rbind(adata_m1, adata_m3)
adata_spec$response=factor(adata_spec$response,levels=c('model1', 'model3'))
tsum_spec13=t.test(y~response,data=adata_spec,alternative='two.sided',var.equal=F,paired=F)  
csum_spec13=cohens_d(y~response,data=adata_spec,paired=F,var.equal=F)

# t-test for pcr model vs. model 3 
adata_spec=rbind(adata_pcr, adata_m3)
adata_spec$response=factor(adata_spec$response,levels=c('exposure','model3'))
tsum_spec_pcr3=t.test(y~response,data=adata_spec,alternative='two.sided',var.equal=F,paired=F)  
csum_spec_pcr3=cohens_d(y~response,data=adata_spec,paired=F,var.equal=F)

### Create Table of Performance Metrics ###

# adjust p-values w/ Benjamini-Hochberg correction method, which controls the false discovery rate (the expected proportion of false discoveries amongst the rejected hypotheses)
ps=c(tsum_auc_pcrcomp$p.value,
     tsum_sens_pcrcomp$p.value,
     tsum_spec_pcrcomp$p.value)
ps_adjust_pcrcomp <- sprintf("%.4f",p.adjust(ps,method="BH"))

ps=c(tsum_auc12$p.value,
     tsum_sens12$p.value,
     tsum_spec12$p.value)
ps_adjust12 <- sprintf("%.4f",p.adjust(ps,method="BH"))   

ps=c(tsum_auc13$p.value,
     tsum_sens13$p.value,
     tsum_spec13$p.value)
ps_adjust13 <- sprintf("%.4f",p.adjust(ps,method="BH")) 

ps=c(tsum_auc_pcr3$p.value,
     tsum_sens_pcr3$p.value,
     tsum_spec_pcr3$p.value)
ps_adjust_pcr3 <- sprintf("%.4f",p.adjust(ps,method="BH")) 

### combine performance measures ###
table_perf_metrics <- data.frame(matrix(c(
                                          "Host exposure", pcr_auc_mean, pcr_sens_mean, pcr_spec_mean,
                                          "Host susceptibility", comp_auc_mean, comp_sens_mean, comp_spec_mean,
                                          "t-test", sprintf("%.4f", tsum_auc_pcrcomp$statistic),
                                          sprintf("%.4f", tsum_sens_pcrcomp$statistic),
                                          sprintf("%.4f", tsum_spec_pcrcomp$statistic),
                                          "p-value", ps_adjust_pcrcomp,
                                          "Cohen's d", sprintf("%.4f", csum_auc_pcrcomp$effsize),
                                          sprintf("%.4f", csum_sens_pcrcomp$effsize),
                                          sprintf("%.4f", csum_spec_pcrcomp$effsize),

                                          "Link prediction", m1_auc_mean, m1_sens_mean, m1_spec_mean,
                                          "Link prediction excluding VACV links", m2_auc_mean, m2_sens_mean, m2_spec_mean,
                                          "t-test", sprintf("%.4f", tsum_auc12$statistic),
                                          sprintf("%.4f", tsum_sens12$statistic),
                                          sprintf("%.4f", tsum_spec12$statistic),
                                          "p-value", ps_adjust12,
                                          "Cohen's d", sprintf("%.4f", csum_auc12$effsize),
                                          sprintf("%.4f", csum_sens12$effsize),
                                          sprintf("%.4f", csum_spec12$effsize),

                                          "Link prediction", m1_auc_mean, m1_sens_mean, m1_spec_mean,
                                          "Link prediction with host traits only", m3_auc_mean, m3_sens_mean, m3_spec_mean,
                                          "t-test", sprintf("%.4f", tsum_auc13$statistic),
                                          sprintf("%.4f", tsum_sens13$statistic),
                                          sprintf("%.4f", tsum_spec13$statistic),
                                          "p-value", ps_adjust13,
                                          "Cohen's d", sprintf("%.4f", csum_auc13$effsize),
                                          sprintf("%.4f", csum_sens13$effsize),
                                          sprintf("%.4f", csum_spec13$effsize),
                                        
                                          "Host exposure", pcr_auc_mean, pcr_sens_mean, pcr_spec_mean,
                                          "Link prediction with host traits only", m3_auc_mean, m3_sens_mean, m3_spec_mean,
                                          "t-test", sprintf("%.4f", tsum_auc_pcr3$statistic),
                                          sprintf("%.4f", tsum_sens_pcr3$statistic),
                                          sprintf("%.4f", tsum_spec_pcr3$statistic),
                                          "p-value", ps_adjust_pcr3,
                                          "Cohen's d", sprintf("%.4f", csum_auc_pcr3$effsize),
                                          sprintf("%.4f", csum_sens_pcr3$effsize),
                                          sprintf("%.4f", csum_spec_pcr3$effsize)),
                                  ncol=4, byrow=TRUE))

# rename columns and rownames
colnames(table_perf_metrics) <- c('Model', 'AUC (mean \u00b1 SE)', 'Sensitivity (mean \u00b1 SE)', 'Specificity (mean \u00b1 SE)')

# save as supp table 1
write.csv(table_perf_metrics, "figures/supplementary/s1table_perf_metrics.csv")

# clean environment
rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3",
                        "adata_auc_all", "adata_sens_all", "adata_spec_all")))

```

### How do performance measures change when we apply different optimal threshold values (e.g., based on maximizing sensitivity + specificity)?

```{r perf_thv}

### OPTION 1 ### 
# Get optimized THV from the predicted probabilities of all 100 iterations

# row-bind predicted values of all iterations for each model
model_pcr = lapply(pcr_brts, function(x) x$predict)
model_pcr=do.call(rbind, model_pcr)

model_comp = lapply(comp_brts, function(x) x$predict)
model_comp=do.call(rbind, model_comp)

model1=lapply(brts1,function(x) x$predict)
model1=do.call(rbind,model1)

model2=lapply(brts2,function(x) x$predict)
model2=do.call(rbind,model2)

model3=lapply(brts3,function(x) x$predict)
model3=do.call(rbind,model3)

# build an ROC curve from the predicted probabilities of all iterations (and known links) 
roc_pcr <- roc(model_pcr$pcr,model_pcr$cpred, auc=TRUE, ci=TRUE)
roc_comp <- roc(model_comp$comp,model_comp$cpred, auc=TRUE, ci=TRUE)
roc1 <- roc(model1$link,model1$cpred, auc=TRUE, ci=TRUE)
roc2 <- roc(model2$link,model2$cpred, auc=TRUE, ci=TRUE)
roc3 <- roc(model3$link,model3$cpred, auc=TRUE, ci=TRUE)

# plot ROC curves
plot(roc_pcr, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"), max.auc.polygon=TRUE,
  auc.polygon.col="lightblue", print.thres=TRUE) #print.thres based on max(sens+spec)

plot(roc_comp, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"), max.auc.polygon=TRUE,
  auc.polygon.col="lightblue", print.thres=TRUE) #print.thres based on max(sens+spec)

plot(roc1, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"), max.auc.polygon=TRUE,
  auc.polygon.col="lightblue", print.thres=TRUE) #print.thres based on max(sens+spec)

plot(roc2, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"), max.auc.polygon=TRUE,
  auc.polygon.col="lightblue", print.thres=TRUE)

plot(roc3, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"), max.auc.polygon=TRUE,
  auc.polygon.col="lightblue", print.thres=TRUE)

# get optimum THV by finding THV when sens+spec are maximized for each model
tss <- cbind(roc_pcr$thresholds, roc_pcr$sensitivities + roc_pcr$specificities)
thv_pcr_mss <- subset(tss, tss[,2]==max(tss[,2]))[,1]

tss <- cbind(roc_pcr$thresholds, roc_comp$sensitivities + roc_comp$specificities)
thv_comp_mss <- subset(tss, tss[,2]==max(tss[,2]))[,1]

tss <- cbind(roc1$thresholds, roc1$sensitivities + roc1$specificities)
thv1_mss <- subset(tss, tss[,2]==max(tss[,2]))[,1]

tss <- cbind(roc2$thresholds, roc2$sensitivities + roc2$specificities)
thv2_mss <- subset(tss, tss[,2]==max(tss[,2]))[,1] 

tss <- cbind(roc3$thresholds, roc3$sensitivities + roc3$specificities)
thv3_mss <- subset(tss, tss[,2]==max(tss[,2]))[,1]

### OPTION 2 ### 
# Get optimized THV averaged across all 100 model iterations based on predicted probs

# build individual ROCs for each iteration; compile as a list
roc_pcr=lapply(pcr_brts,function(x) roc(x$predict$pcr,x$predict$cpred, auc=TRUE,ci=TRUE))
roc_comp=lapply(comp_brts,function(x) roc(x$predict$comp,x$predict$cpred, auc=TRUE,ci=TRUE))
roc1=lapply(brts1,function(x) roc(x$predict$link,x$predict$cpred, auc=TRUE,ci=TRUE))
roc2=lapply(brts2,function(x) roc(x$predict$link,x$predict$cpred, auc=TRUE,ci=TRUE))
roc3=lapply(brts3,function(x) roc(x$predict$link,x$predict$cpred, auc=TRUE,ci=TRUE))

# calculate mean AUC from roc (thv=0.5)
auc=unlist(lapply(roc_pcr, function(x) x$auc))
mean(auc)
std.error(auc)

auc=unlist(lapply(roc_comp, function(x) x$auc))
mean(auc)
std.error(auc)

auc=unlist(lapply(roc1, function(x) x$auc))
mean(auc)
std.error(auc)

auc=unlist(lapply(roc2, function(x) x$auc))
mean(auc)
std.error(auc)

auc=unlist(lapply(roc3, function(x) x$auc))
mean(auc)
std.error(auc)

# plot ROC curves
plot(roc_pcr[[1]])
for (i in 2:length(roc_pcr)) {
   plot(roc_pcr[[i]], add=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"))
} 

plot(roc_comp[[1]])
for (i in 2:length(roc_comp)) {
   plot(roc_comp[[i]], add=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"))
} 

plot(roc1[[1]])
for (i in 2:length(roc1)) {
   plot(roc1[[i]], add=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"))
}

plot(roc2[[1]])
for (i in 2:length(roc2)) {
   plot(roc2[[i]], add=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"))
} 

plot(roc3[[1]])
for (i in 2:length(roc3)) {
   plot(roc3[[i]], add=TRUE, grid=c(0.1, 0.2),
  grid.col=c("gray", "gray"))
} 

# for each iteration's ROC, extract the threshold value and the sum of sensitivity + specificity
tss_pcr=lapply(roc_pcr, function(x) cbind(x$thresholds, x$sensitivities + x$specificities))
tss_comp=lapply(roc_comp, function(x) cbind(x$thresholds, x$sensitivities + x$specificities))
tss1=lapply(roc1, function(x) cbind(x$thresholds, x$sensitivities + x$specificities))
tss2=lapply(roc2, function(x) cbind(x$thresholds, x$sensitivities + x$specificities))
tss3=lapply(roc3, function(x) cbind(x$thresholds, x$sensitivities + x$specificities))


# for each iteration, extract the threshold value where sens+spec were maximized
thv_pcr_mss = lapply(tss_pcr, function(x) subset(x, x[,2]==max(x[,2]))[,1])
thv_comp_mss = lapply(tss_comp, function(x) subset(x, x[,2]==max(x[,2]))[,1])
thv1_mss = lapply(tss1, function(x) subset(x, x[,2]==max(x[,2]))[,1])
thv2_mss = lapply(tss2, function(x) subset(x, x[,2]==max(x[,2]))[,1])
thv3_mss = lapply(tss3, function(x) subset(x, x[,2]==max(x[,2]))[,1])

# get the mean and standard error of those threshold values; this is our calculated optimal threshold value
thv_pcr_mss_mean = mean(sapply(thv_pcr_mss, function(x) x))
thv_pcr_mss_se = se(sapply(thv_pcr_mss, function(x) x))

thv_comp_mss_mean = mean(sapply(thv_comp_mss, function(x) x))
thv_comp_mss_se = se(sapply(thv_comp_mss, function(x) x))

thv1_mss_mean = mean(sapply(thv1_mss, function(x) x))
thv1_mss_se = se(sapply(thv1_mss, function(x) x))

thv2_mss_mean = mean(sapply(thv2_mss, function(x) x))
thv2_mss_se = se(sapply(thv2_mss, function(x) x))

thv3_mss_mean = mean(sapply(thv3_mss, function(x) x))
thv3_mss_se = se(sapply(thv3_mss, function(x) x))

# for each iteration, get the coordinates (sensitivity & specificity) of the ROC curve applying the mean threshold value
coords_pcr = lapply(roc_pcr, function(x) coords(x, thv_pcr_mss_mean, input="threshold"))
coords_comp = lapply(roc_comp, function(x) coords(x, thv_comp_mss_mean, input="threshold"))
coords1 = lapply(roc1, function(x) coords(x, thv1_mss_mean, input="threshold"))
coords2 = lapply(roc2, function(x) coords(x, thv2_mss_mean, input="threshold"))
coords3 = lapply(roc3, function(x) coords(x, thv2_mss_mean, input="threshold"))

# extract sens and spec values from coordinate points
coords_pcr_sens = unlist(lapply(coords_pcr, function(x) x$sensitivity))
coords_pcr_spec = unlist(lapply(coords_pcr, function(x) x$specificity))

coords_comp_sens = unlist(lapply(coords_comp, function(x) x$sensitivity))
coords_comp_spec = unlist(lapply(coords_comp, function(x) x$specificity))

coords1_sens = unlist(lapply(coords1, function(x) x$sensitivity))
coords1_spec = unlist(lapply(coords1, function(x) x$specificity))

coords2_sens = unlist(lapply(coords2, function(x) x$sensitivity))
coords2_spec = unlist(lapply(coords2, function(x) x$specificity))

coords3_sens = unlist(lapply(coords3, function(x) x$sensitivity))
coords3_spec = unlist(lapply(coords3, function(x) x$specificity))

# calculate corresponding mean sens and spec
mean(coords_pcr_sens)
std.error(coords_pcr_sens)

mean(coords_comp_sens)
std.error(coords_comp_sens)

mean(coords1_sens)
std.error(coords1_sens)

mean(coords2_spec)
std.error(coords2_spec)

mean(coords3_sens)
std.error(coords3_sens)

# Get optimized AUC
AUC_optimized <- unlist(lapply(roc_pcr, function(x) pROC::auc(x, thresholds=thv_pcr_mss_mean)))
AUC_optimized_mean <- mean(AUC_optimized)
print(AUC_optimized_mean)

AUC_optimized <- unlist(lapply(roc_comp, function(x) pROC::auc(x, thresholds=thv_comp_mss_mean)))
AUC_optimized_mean <- mean(AUC_optimized)
print(AUC_optimized_mean)

AUC_optimized <- unlist(lapply(roc1, function(x) pROC::auc(x, thresholds=thv1_mss_mean)))
AUC_optimized_mean <- mean(AUC_optimized)
print(AUC_optimized_mean)

AUC_optimized <- unlist(lapply(roc2, function(x) pROC::auc(x, thresholds=thv2_mss_mean)))
AUC_optimized_mean <- mean(AUC_optimized)
print(AUC_optimized_mean)

AUC_optimized <- unlist(lapply(roc3, function(x) pROC::auc(x, thresholds=thv3_mss_mean)))
AUC_optimized_mean <- mean(AUC_optimized)
print(AUC_optimized_mean)

### OPTION 3 ### 
# Get optimum THV based on the ROC curve: maximize TRP and FPR (true/false positive rate) by minimizing |FPR + TPR - 1|, which is equal to minimizing |sensitivity - specificity|.

# Model 1: Unlist and extract sensitivity, specificity and threshold values
sensitivities <- unlist(lapply(roc1, function(x) x$sensitivities))
specificities <- unlist(lapply(roc1, function(x) x$specificities))
thresholds <- unlist(lapply(roc1, function(x) x$thresholds))

# Model 1: Combine values into df
df <- as.data.frame(cbind(sensitivities, specificities, thresholds))
colnames(df) <- c("sens", "spec", "thresh")
df <- subset(df, is.finite(df$thresh))

# Model 1: Create variable = |sensitivity - specificity|
df$sens_spec <- abs(df$sens - df$spec)

# Model 1: Plot sens_spec to see threshold level at minimum 
ggplot(df, aes(thresh, sens_spec)) + geom_line()

# Model 1: Get values
df[which.min(df$sens_spec),]
thv1_minss <- df[which.min(df$sens_spec),3]

# Model 1: Get optimized AUC
roc1 <- roc(model1$link,model1$cpred)
AUC_optimized <- auc(roc1, thresholds = thv1_minss)
print(AUC_optimized)

# Clean environment
# rm(list=setdiff(ls(), c("adata","brts1","brts2","sedata","spdata")))
rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3",
                        "adata_auc_all", "adata_sens_all", "adata_spec_all")))

```

### *Generate boxplot of model performance*
Figures: *fig1_boxplot_model_senspec.png*, *fig1_boxplot_model_auc.png*

```{r perf_boxplot}

### BOXPLOTS FOR link prediction models 1 and 3 and host trait models only

# subset model performance data 
adata_auc = subset(adata_auc_all, response!="model2")
adata_sens = subset(adata_sens_all, response!="model2")
adata_spec = subset(adata_spec_all, response!="model2")

# transform 'response' to factor 
adata_auc$response=factor(adata_auc$response,levels=c('model1', 'model3','exposure','susceptibility'))
adata_sens$response=factor(adata_sens$response,levels=c('model1', 'model3','exposure','susceptibility'))
adata_spec$response=factor(adata_spec$response,levels=c('model1', 'model3','exposure','susceptibility'))

# create list of dataframes
list_dfs <- list(adata_auc, adata_sens, adata_spec)

# generate additional variables needed for plotting model performance
for (i in 1:length(list_dfs)){
  
  ## make jitter position to spread out points along the x-coordinate
  list_dfs[[i]]$x=as.numeric(factor(list_dfs[[i]]$response))
  set.seed(1234)
  list_dfs[[i]]$xj=jitter(list_dfs[[i]]$x,0.5)
  
  ## fix response
  list_dfs[[i]]$respond2=plyr::revalue(list_dfs[[i]]$response,c( "model1"="Host-virus links",
                                                                 "model3"="Host-virus links \n (model trained on \n host traits only)",
                                                                 "exposure"="RT-PCR \n positivity",
                                                                 "susceptibility"="Virus isolation"))
}

# Unlist
df_auc <- as.data.frame(list_dfs[[1]])
df_sens <- as.data.frame(list_dfs[[2]])
df_spec <- as.data.frame(list_dfs[[3]])

# Add type variable
df_auc$type="AUC"
df_sens$type="Sensitivity"
df_spec$type="Specificity"

# Aggregate sens and spec datasets
sdata=rbind.data.frame(df_sens, df_spec)


### BOXPLOTS FOR ALL MODELS

# AUC - save as figure 1
png("figures/fig1_boxplot_model_auc.png",width=6,height=6,units="in",res=600)
ggplot(df_auc)+
  geom_boxplot(aes(x=x,y=y,group=x),width=0.5,alpha=0.25,outlier.alpha=0)+
  geom_point(aes(x=xj,y=y),size=1.5,alpha=0.5)+
  scale_x_continuous(breaks=c(1,2,3,4),
                     labels=c("Link prediction",
                              "Link prediction \n trained on \n host traits only",
                              "Host exposure",
                              "Susceptible host"),
                     limits=c(0.5,4.5))+
  theme_bw()+
  labs(x="Model",
       y="Area under the curve (AUC)")+
  theme(axis.text=element_text(size=10),
        axis.text.x=element_text(size=8),
        axis.title=element_text(size=12))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+
  guides(colour="none")
dev.off()

# sensitivity and specificity - save as figure 1
png("figures/fig1_boxplot_model_senspec.png",width=6,height=6,units="in",res=600)
ggplot(sdata) +
  geom_boxplot(aes(x=x,y=y,group=x),width=0.5,alpha=0.25,outlier.alpha=0)+
  geom_point(aes(x=xj,y=y),size=1.5,alpha=0.5)+
  scale_x_continuous(breaks=c(1,2,3,4),
                     labels=c("Link prediction",
                              "Link prediction \n trained on \n host traits only",
                              "Host exposure",
                              "Susceptible host"),
                     limits=c(0.5,4.5))+
  theme_bw()+
  facet_wrap(~type,scales="free_y",strip.position="left",ncol=1)+
  theme(strip.placement="outside",
        strip.background=element_blank())+
  labs(x="Model",
       y=NULL)+
  theme(axis.text.y=element_text(size=10),
        axis.text.x=element_text(size=8),
        axis.title=element_text(size=12),
        strip.text=element_text(size=12))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+
  guides(colour="none")
dev.off()

rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3")))
```


### *Evaluate distribution of MPXV sequences in train and test datasets from link prediction model (Model 1) results using 'cites' variable as proxy*
To ensure that MPXV sequences were well distributed between train and test dataset, we plot 'cites' for each train and test datasets for each iteration. 

```{r perf_mpxv}

# extract cites from brts1 train data
ctrain=lapply(brts1,function(x) x$traindata$cites)
ctrain=do.call(rbind, ctrain)

# convert to matrix
cmat_train = as.matrix(ctrain)
cmat_train = t(cmat_train)

# change colnames
colnames(cmat_train) = paste("iter", seq(ncol(cmat_train)), sep="")

# convert to dataframe
dat_train = as.data.frame(cmat_train)
dat_train$obs = rownames(dat_train)

# reshape wide to long
mdat_train = reshape2::melt(dat_train, id.vars="obs")
# mdat_train$obs = as.numeric(gsub("obs", "", mdat_train$variable))
mdat_train$iter = as.factor(mdat_train$variable)
mdat_train$log10_cites = as.numeric(log10(mdat_train$value))
mdat_train$obs = as.numeric(mdat_train$obs)

# plot as line graph by iteration
p_train = ggplot(mdat_train, aes(x=obs, y=log10_cites, color=iter)) +
    theme_bw() + theme(panel.grid=element_blank()) +
    theme(legend.position="none") +
    geom_line(linewidth=0.2, alpha=0.1) +
    stat_summary(aes(y = log10_cites), fun=mean, color="black", geom="line", linewidth=0.2, alpha=0.4)

# save plot
png("figures/other/linkpred/plot_perf_mpxv_train.png",width=20,height=15,units="in",res=300)
p_train
dev.off()

# extract cites from brts1 train data
ctest=lapply(brts1,function(x) x$testdata$cites)
ctest=do.call(rbind, ctest)

# convert to matrix
cmat_test = as.matrix(ctest)
cmat_test = t(cmat_test)

# change colnames
colnames(cmat_test) = paste("iter", seq(ncol(cmat_test)), sep="")

# convert to dataframe
dat_test = as.data.frame(cmat_test)
dat_test$obs = rownames(dat_test)

# reshape wide to long
mdat_test = reshape2::melt(dat_test, id.vars="obs")
# mdat_train$obs = as.numeric(gsub("obs", "", mdat_train$variable))
mdat_test$iter = as.factor(mdat_test$variable)
mdat_test$log10_cites = as.numeric(log10(mdat_test$value))
mdat_test$obs = as.numeric(mdat_test$obs)

# plot as line graph by iteration
ggplot(mdat_test, aes(x=obs, y=log10_cites, color=iter)) +
    theme_bw() + theme(panel.grid=element_blank()) +
    theme(legend.position="none") +
    geom_line(linewidth=0.2, alpha=0.1) +
    stat_summary(aes(y = log10_cites), fun=mean, colour="black", geom="line", linewidth=0.2, alpha=0.4)


# Replot for iter 3 for train and test data
ggplot(mdat_train[mdat_train$iter=="iter1" | mdat_train$iter=="iter2" | mdat_train$iter=="iter3" | mdat_train$iter=="iter4" | mdat_train$iter=="iter5",], aes(x=obs, y=log10_cites, color=iter)) +
    theme_bw() + theme(panel.grid=element_blank()) +
    geom_line(linewidth=0.2, alpha=1) 
ggplot(mdat_test[mdat_test$iter=="iter1" | mdat_test$iter=="iter2" | mdat_test$iter=="iter3" | mdat_test$iter=="iter4" | mdat_test$iter=="iter5",], aes(x=obs, y=log10_cites, color=iter)) +
    theme_bw() + theme(panel.grid=element_blank()) +
    geom_line(linewidth=0.2, alpha=1)

# clean environment
rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3")))

```


2. Model Predictions
====================
We examine predictions from our BRT models assessing the predicted probabilities of OPV positivity and host-virus links. 

### *Load required packages and set system*

```{r pred_load}

# Libraries for BRT figures
library(tidyr)
library(ggplot2)
library(sciplot)
library(fastDummies)
library(caper)
library(ape)
library(phylofactor)
library(plotrix) #std.error
library(rstatix)
library(ggrepel)
library(ggpubr) #ggarrange
library(plyr)
library(dplyr)
library(openxlsx)
library(readxl)
library(PresenceAbsence) #for thresholding results

# Clean environment
rm(list=ls()) 
graphics.off()

# Set working directory
setwd("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost")


```


### *Extract and save predicted probabilities for host trait models*
Table: *table_predprobs_hosttrait.csv*
Other Figures: *plot_predprobs_hosttrait.png*

```{r pred_host}

### Extract Predicted Probabilities ###

# load data
pcr_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/pcr_brts.rds")
comp_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/comp_brts.rds")

# load cleaned data file
library(fastDummies)
load("data/hosttrait_cleandata.RData")
data <- poxdata

# make binary columns for each taxonomic family in our dataset
dums=dummy_cols(data["fam"])

# get only unique observations
dums=dums[!duplicated(dums$fam),]

# ensure all are factor
for(i in 1:ncol(dums)){
  
  ## column as factor
  dums[,i]=factor(dums[,i])
  
}

# merge family variables with poxdata
data=merge(data,dums,by="fam",all.x=T)
rm(dums)

# get predicted probabilities from PCR model
pcr_apreds=lapply(pcr_brts,function(x) x$predict)
pcr_apreds=do.call(rbind,pcr_apreds)

# collapse to mean of predicted probabilities for each unique treename/tip
pcr_apreds=data.frame(aggregate(pred~treename,data=pcr_apreds,mean),
                      aggregate(cpred~treename,data=pcr_apreds,mean)['cpred'], ## holding wos constant
                      aggregate(pcr~treename,data=pcr_apreds,prod)["pcr"],
                      aggregate(competence~treename,data=pcr_apreds,prod)["competence"])

# generate variable of evidence type for PCR model
pcr_apreds$type='PCR'

# get predicted probabilities from virus isolation model
comp_apreds=lapply(comp_brts,function(x) x$predict)
comp_apreds=do.call(rbind,comp_apreds)

# collapse to mean of predicted probabilities for each unique treename/tip
comp_apreds=data.frame(aggregate(pred~treename,data=comp_apreds,mean),
                       aggregate(cpred~treename,data=comp_apreds,mean)['cpred'], ## holding wos constant
                       aggregate(pcr~treename,data=comp_apreds,prod)["pcr"],
                       aggregate(competence~treename,data=comp_apreds,prod)["competence"])

# generate variable of evidence type for virus isolation model
comp_apreds$type='competence'

# combine predictions from both model types
apreds=rbind.data.frame(pcr_apreds,comp_apreds)

# add studies variable
apreds=merge(apreds,data[c("treename","studies")],by="treename")

# generate positivity variable
apreds$positivity=ifelse(apreds$pcr==1 & apreds$type=="PCR",1,
                         ifelse(apreds$competence==1 & apreds$type=='competence',1,0))

# generate variable of studied (unsampled) or not studied (positive/negative)
apreds$cat=ifelse(apreds$studies==0,"unsampled",
                  ifelse(apreds$positivity==1,"positive","negative"))

# generate evidence type variable
apreds$type=factor(apreds$type,levels=c("PCR","competence"))
apreds$type2=plyr::revalue(apreds$type,c("PCR"="infection"))

# transform apreds long to wide
apreds2=tidyr::spread(apreds[c('treename','type','cpred')],type,cpred)
comp_apreds$comp=comp_apreds$competence

# merge with comp_apreds
apreds2=merge(apreds2,comp_apreds[c("treename","pcr","comp")],by="treename")

# xix variable names
names(apreds2)=c("treename","pred_pcr","pred_comp","PCR","competence")

# classify true negatives
data$type=ifelse(data$studies>0 & data$pcr==0 & data$competence==0,"true negative","other")

# merge with data
apreds2=merge(apreds2,data[c("treename","type","studies","ord","fam","gen")],by='treename')

# fix cat variable
apreds2$cat=ifelse(apreds2$studies==0,"unsampled",
                   ifelse(apreds2$PCR==0 & apreds2$competence==0,"negative","positive"))

# make cat variable factor
apreds2$cat=factor(apreds2$cat,c("positive",'negative','unsampled'))
apreds$cat=factor(apreds$cat,levels=levels(apreds2$cat))

# fix label of type2 variable
apreds$type2=plyr::revalue(apreds$type2,
                     c("infection"="Infection",
                       "competence"="Competence"))

# save as new dataframe and drop unnecessary variables
preds=apreds2
preds$fam=NULL
preds$gen=NULL

# save file
write.csv(preds,"figures/other/hosttrait/table_predprobs_hosttrait.csv")

# save apreds and apreds2 as new dfs for later
apreds_host <- apreds
apreds2_host <- apreds2

### Visualize Distribution of Predicted Probabilities ###

# load library for color palette; select and re-order colors
remotes::install_github("awhstin/awtools")
library(awtools)
cc=mpalette[2:4]
cc=rev(cc)

# density plot of predicted probabilities
densityplot_pp=ggplot(apreds,aes(cpred)) +
  geom_density(aes(fill=cat,colour=cat),alpha=0.5)+
  facet_wrap(~type2,ncol=1,strip.position='top',scales="free_y")+
  theme_bw()+ 
  theme(legend.position="top")+ 
  labs(x=expression(paste("Predicted probability (",italic(P),") of hosting")))+ 
  xlim(0,1)+ 
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=12), 
        legend.title=element_text(size=12),
        legend.text=element_text(size=11), 
        strip.text=element_text(size=11), 
        legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(20,20,20,20))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+ 
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+ 
  scale_colour_manual(values=cc)+ 
  scale_fill_manual(values=cc)+
  guides(colour=guide_legend(title="(a) Orthopoxvirus positivity"),
         fill=guide_legend(title="(a) Orthopoxvirus positivity")) 
densityplot_pp

# scatterplot of predicted probabilities 
scatterplot_pp=ggplot(apreds2,aes(pred_pcr,pred_comp))+ 
  geom_point(alpha=0.5,size=2,aes(colour=cat,fill=cat))+ 
  geom_smooth(method='gam',colour="grey")+
  labs(x=expression(paste(italic(P),' from RT-PCR models')), 
       y=expression(paste(italic(P),' from virus isolation models')))+
  theme_bw()+ 
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=12),
        legend.title=element_text(size=12), 
        legend.text=element_text(size=11), 
        strip.text=element_text(size=11), 
        legend.margin=margin(0,0,0,0), 
        legend.box.margin=margin(20,20,20,20))+ 
  theme(legend.position="top")+ 
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+ 
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+ 
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+ 
  scale_colour_manual(values=cc)+ 
  scale_fill_manual(values=cc)+ 
  guides(colour=guide_legend(title="(a) Orthohantavirus positivity"), 
         fill=guide_legend(title="(a) Orthohantavirus positivity")) 
scatterplot_pp 

# combine and save density plot with scatterplot of predicted probabilities
png("figures/other/hosttrait/plot_predprobs_hosttrait.png",width=6.5,height=4,units="in",res=300)
plot_pp=ggarrange(densityplot_pp,scatterplot_pp,common.legend=T) 
plot_pp 
dev.off() 

rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3")))

```

### *Extract and save predicted probabilities for link prediction models*
Table: *table_predprobs_link.xlsx*

```{r pred_link}

### Extract Predicted Probabilities ###

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model1/brts_Model1.RData")
brts1=brts # link prediction model 1 - including VACV links
rm(brts, pm_brts) 

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model2/brts_Model2.RData")
brts2=brts # link prediction model 2 - excluding VACV links
rm(brts, pm_brts)

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model3/brts_Model3.RData")
brts3=brts # link prediction model 3 - including VACV links and host traits only
rm(brts, pm_brts)

# load cleaned data file
library(fastDummies)
load("data/linkpred_cleandata.RData")
data <- linkdata

# make binary columns for each taxonomic family in our dataset
dums=dummy_cols(data["fam"])

# get only unique observations
dums=dums[!duplicated(dums$fam),]

# ensure all are factor
for(i in 1:ncol(dums)){
  ## column as factor
  dums[,i]=factor(dums[,i])
}

# merge family variables with poxdata
data=merge(data,dums,by="fam",all.x=T)
rm(dums)

# get predicted probabilities from models
model1_apreds=lapply(brts1,function(x) x$predict)
model1_apreds=do.call(rbind,model1_apreds)

model2_apreds=lapply(brts2,function(x) x$predict)
model2_apreds=do.call(rbind,model2_apreds)

model3_apreds=lapply(brts3,function(x) x$predict)
model3_apreds=do.call(rbind,model3_apreds)

# collapse to mean of predicted probabilities for each unique treename/tip
model1_apreds=data.frame(aggregate(pred~treename+virus,data=model1_apreds,mean), 
                        aggregate(cpred~treename+virus,data=model1_apreds,mean)['cpred'],
                        aggregate(link~treename+virus,data=model1_apreds,prod)['link'])

model2_apreds=data.frame(aggregate(pred~treename+virus,data=model2_apreds,mean),
                       aggregate(cpred~treename+virus,data=model2_apreds,mean)['cpred'],
                       aggregate(link~treename+virus,data=model2_apreds,prod)['link'])

model3_apreds=data.frame(aggregate(pred~treename+virus,data=model3_apreds,mean),
                       aggregate(cpred~treename+virus,data=model3_apreds,mean)['cpred'],
                       aggregate(link~treename+virus,data=model3_apreds,prod)['link'])

# generate variable of model type/number
model1_apreds$type='Model1'
model2_apreds$type='Model2'
model3_apreds$type='Model3'

# Combine predictions from all models
apreds=rbind.data.frame(model1_apreds, model2_apreds, model3_apreds)

# Transform type variable to factor and generate new type variable and revalue
library(plyr)
apreds$type=factor(apreds$type,levels=c("Model1","Model2","Model3"))
apreds$type2=revalue(apreds$type,
                     c("Model1"="Link prediction model",
                       "Model2"="Link prediction model excluding VACV links",
                       "Model3"="Link prediction model trained on host traits only"))

# Transform apreds long to wide, keeping cpred b/c these are our predicted probabilities after holding citations at their average (by isolating their effect on prediction, we control for the confounding effects of citations)
apreds2=spread(apreds[c('virus','treename','type','cpred')],type,cpred)
model1_apreds$link1=model1_apreds$link
model2_apreds$link2=model2_apreds$link
model3_apreds$link3=model3_apreds$link

# Merge with apreds2
apreds2=merge(apreds2,model1_apreds[c("virus","treename","link1")],by=c("virus","treename"),all=TRUE)
apreds2=merge(apreds2,model2_apreds[c("virus","treename","link2")],by=c("virus","treename"),all=TRUE)
apreds2=merge(apreds2,model3_apreds[c("virus","treename","link3")],by=c("virus","treename"),all=TRUE)

# Check that datasets merged correctly, links for VACV should be NA for 'Model2' and 'link2'
View(apreds2[apreds2$virus=="vaccinia virus",])

# Fix variable names
names(apreds2)=c("virus","treename","pred_Model1","pred_Model2","pred_Model3","link1","link2","link3")

# Merge with data
apreds2=merge(apreds2,data[c("virus","treename","source","ord","fam","genus")],by=c('virus','treename'),all.x=TRUE)

# View(apreds2[duplicated(apreds2),]) #check
apreds2 <- apreds2[!duplicated(apreds2),]
apreds=merge(apreds,data[c("virus","treename","source")],by=c('virus','treename'),all.x=TRUE)
# View(apreds[duplicated(apreds),]) #check
apreds <- apreds[!duplicated(apreds),]

# Fix source labels
apreds2$cat=ifelse(apreds2$source=="NA","Pseudoabsence",apreds2$source)
apreds2$cat=ifelse(apreds2$source=="both","Virion & WGS",apreds2$cat)
apreds2$cat=ifelse(apreds2$source=="virion","Virion", apreds2$cat)
apreds2$cat=ifelse(apreds2$source=="wgs","WGS", apreds2$cat)

apreds$cat=ifelse(apreds$source=="NA","Pseudoabsence",apreds$source)
apreds$cat=ifelse(apreds$source=="both","Virion & WGS",apreds$cat)
apreds$cat=ifelse(apreds$source=="virion","Virion", apreds$cat)
apreds$cat=ifelse(apreds$source=="wgs","WGS", apreds$cat)

# Fix source type
apreds2$cat=factor(apreds2$cat,c("Pseudoabsence","Virion","Virion & WGS", "WGS"))
apreds$cat=factor(apreds$cat,levels=levels(apreds2$cat))

# Save apreds and apreds2 as new df for later
apreds_link <- apreds
apreds2_link <- apreds2

# Reformat for saving
preds=apreds2
preds$source=preds$cat
library(stringr)
preds$fam=str_to_title(preds$fam)
preds$ord=str_to_title(preds$ord)

# Subset predictions for each model and save
preds1=preds[c("source","virus","treename","fam","ord","pred_Model1","link1")]
preds2=preds[c("source","virus","treename","fam","ord","pred_Model2","link2")]
preds3=preds[c("source","virus","treename","fam","ord","pred_Model3","link3")]

# Combine as list and save as xlsx file
preds123 <- list("model1" = preds1, "model2" = preds2, "model3" = preds3)
write.xlsx(preds123, file = "figures/other/linkpred/table_predprobs_link.xlsx")

# ### KATIE, CHECK THIS CODE ###
# #(22) Print predicted links organized by virus and source for discussion
# preds1=preds1[order(preds1$virus,preds1$source,-preds1$pred_Model1),]
# paste0("Predicted links for Model 1 by virus and source")
# preds1[preds1$pred_Model1>0.5,]
# length(which(preds1$pred_Model1>0.5))
# length(which(preds1$pred_Model1>thv1_mss_mean))
# length(which(preds1$pred_Model1>thv1_minss))
# 
# preds2=preds2[order(preds2$virus,preds2$source,-preds2$pred_Model2),]
# paste0("Predicted links for Model 2 by virus and source")
# preds2[preds2$pred_Model2>0.5,]
# length(which(preds2$pred_Model2>0.5))
# length(which(preds2$pred_Model2>thv2_mss_mean))

# ###KATIE, CHECK THIS CODE###

### Visualize Distribution of Predicted Probabilities ###

# Load library for color palette; select and re-order colors
remotes::install_github("awhstin/awtools")
library(awtools)
cc=mpalette[2:5] 
cc=rev(cc)

# Density plot of predicted probabilities
densityplot_pp=ggplot(apreds,aes(cpred))+
  geom_density(aes(fill=cat,colour=cat),alpha=0.5)+
  facet_wrap(~type2,ncol=1,strip.position='top',scales="free_y")+
  theme_bw()+
  theme(legend.position="top")+
  labs(x=expression(paste("Predicted probability (",italic(P),") of link")))+
  xlim(0,0.1)+
  # xlim(thv1_mss_mean,1)+
  theme(axis.text=element_text(size=10),
        axis.title=element_text(size=12),
        legend.title=element_text(size=12),
        legend.text=element_text(size=11),
        strip.text=element_text(size=11),
        legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(20,20,20,20))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+
  scale_colour_manual(values=cc)+
  scale_fill_manual(values=cc)+
  guides(colour=guide_legend(title="(a) Host-OPV positivity"),
         fill=guide_legend(title="(a) Host-OPV positivity"))

# Scatterplot of predicted probabilities
scatterplot_pp=ggplot(apreds2,aes(pred_Model1,pred_Model2))+
  geom_point(alpha=0.5,size=2,aes(colour=cat,fill=cat))+
  geom_smooth(method='gam',colour="grey")+
  labs(x=expression(paste(italic(P),' from Full Model 1')),
       y=expression(paste(italic(P),' from Partial Model 2')))+
  theme_bw()+
  theme(axis.text=element_text(size=10),
        axis.title=element_text(size=12),
        legend.title=element_text(size=12),
        legend.text=element_text(size=11),
        strip.text=element_text(size=11),
        legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(20,20,20,20))+
  theme(legend.position="top")+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+
  scale_colour_manual(values=cc)+
  scale_fill_manual(values=cc)+
  guides(colour=guide_legend(title="(a) Host-OPV positivity"),
         fill=guide_legend(title="(a) Host-OPV positivity"))

# # Combine density plot with scatterplot of predicted probabilities; save
# png("figures/other/linkpred/plot_predprobs_link.png",width=6.5,height=4,units="in",res=300)
# ggarrange(densityplot_pp,scatterplot_pp,common.legend=T)
# dev.off()

# Clean environment
rm(densityplot_pp,scatterplot_pp, cc, i, preds1, preds2, apreds, apreds2)

```

### *Explore the effects of threshold moving on binary classification*
We calculate various optimal threshold values and evaluate how threshold moving changes classification of OPV positive vs. negative mammal genera and OPV links vs. non-links.
Tables: *table_binarypredictions_pcr.xlsx*, *table_binarypredictions_comp.xlsx*,
        *table_binarypredictions_model1.xlsx*, *table_virusratio_model1.xlsx*
        *table_binarypredictions_model2.xlsx*, *table_virusratio_model2.xlsx*
        *table_binarypredictions_model3.xlsx*, *table_virusratio_model3.xlsx*
        *tables5_thresholdmoving.xlsx*

```{r pred_threshold}

# Set seed
set.seed(12345)

###########################################################################
### Extract Binary Predictions for Host Trait Models ###
###########################################################################

### Calculate Threshold Values ###

pred <- read.csv("figures/other/hosttrait/table_predprobs_hosttrait.csv")

# For the PCR model, let's calculate the opt. threshold values using different optimization methods (e.g., 80% sensitivity)
ts_pcr <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
                           threshold = 10001,
                           opt.methods = c(2,3,4,5,10),
                           req.sens = 0.80,
                           na.rm = TRUE)

# Get 85% sensitivity threshold
ts_pcr[nrow(ts_pcr) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.85,
                           na.rm = TRUE)

# Get 90% sensitivity threshold
ts_pcr[nrow(ts_pcr) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.9,
                           na.rm = TRUE)

# Get 95% sensitivity threshold
ts_pcr[nrow(ts_pcr) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.95,
                           na.rm = TRUE)

# For the virus isolation model, let's calculate the opt. threshold values using different optimization methods (e.g., 80% sensitivity)
ts_comp <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
                           threshold = 10001,
                           opt.methods = c(2,3,4,5,10),
                           req.sens = 0.80,
                           na.rm = TRUE)

# Get 85% sensitivity threshold
ts_comp[nrow(ts_comp) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.85,
                           na.rm = TRUE)

# Get 90% sensitivity threshold
ts_comp[nrow(ts_comp) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.9,
                           na.rm = TRUE)

# Get 95% sensitivity threshold
ts_comp[nrow(ts_comp) + 1,] <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
                           threshold = 10001,
                           opt.methods = c(10),
                           req.sens = 0.95,
                           na.rm = TRUE)


# For PCR model, create function that sums the number of predicted obs (known and unknown) and just known obs; use sapply to view counts
cut_pcr1 <- function(x) {sum(pred$pred_pcr > x)}
cut_pcr2 <- function(x) {sum(pred$pred_pcr[pred$PCR==0] > x)}
sapply(unlist(ts_pcr[2]), cut_pcr1)
sapply(unlist(ts_pcr[2]), cut_pcr2)
sum(pred$PCR)

# For virus isolation model, create function that sums the number of predicted obs (known and unknown) and just known obs; use sapply to view counts
cut_comp1 <- function(x) {sum(pred$pred_comp > x)}
cut_comp2 <- function(x) {sum(pred$pred_comp[pred$competence==0] > x)}
sapply(unlist(ts_comp[2]), cut_comp1)
sapply(unlist(ts_comp[2]), cut_comp2)
sum(pred$competence)

### Create Table of Optimal Thresholding Methods, Values, and Number of Predicted Hosts ###

# Save threshold values as new tables
table_ts_pcr <- ts_pcr
table_ts_comp <- ts_comp

# Correct method labels
table_ts_pcr[5,1] <- "ReqSens 80%"
table_ts_pcr[6,1] <- "ReqSens 85%"
table_ts_pcr[7,1] <- "ReqSens 90%"
table_ts_pcr[8,1] <- "ReqSens 95%"
table_ts_comp[5,1] <- "ReqSens 80%"
table_ts_comp[6,1] <- "ReqSens 85%"
table_ts_comp[7,1] <- "ReqSens 90%"
table_ts_comp[8,1] <- "ReqSens 95%"

# Add new columns for sensitivity, specificity, number of predicted hosts, and number of unknown predicted hosts
table_ts_pcr$threshold <- table_ts_pcr$pred_pcr
table_ts_pcr$pred_pcr <- NULL
table_ts_pcr$sensitivity <- NA
table_ts_pcr$specificity <- NA
table_ts_pcr$n_predicted <- NA
table_ts_pcr$n_predicted_unknown <- NA
table_ts_comp$threshold <- table_ts_comp$pred_comp
table_ts_comp$pred_comp <- NULL
table_ts_comp$sensitivity <- NA
table_ts_comp$specificity <- NA
table_ts_comp$n_predicted <- NA
table_ts_comp$n_predicted_unknown <- NA

# For PCR model, get sensitivity, specificity, and number of predicted hosts based on various threshold values 
for (i in 1:nrow(table_ts_pcr)) {
  table_ts_pcr[i,3] <-  InformationValue::sensitivity(pred$PCR, pred$pred_pcr, threshold = table_ts_pcr[i,2])
  table_ts_pcr[i,4] <-  InformationValue::specificity(pred$PCR, pred$pred_pcr, threshold = table_ts_pcr[i,2])
  table_ts_pcr[i,5] <- cut_pcr1(table_ts_pcr[i,2])
  table_ts_pcr[i,6] <- cut_pcr2(table_ts_pcr[i,2])
}

# For virus isolation model, get sensitivity, specificity, and number of predicted hosts based on various threshold values
for (i in 1:nrow(table_ts_comp)) {
  table_ts_comp[i,3] <-  InformationValue::sensitivity(pred$competence, pred$pred_comp, threshold = table_ts_comp[i,2])
  table_ts_comp[i,4] <-  InformationValue::specificity(pred$competence, pred$pred_comp, threshold = table_ts_comp[i,2])
  table_ts_comp[i,5] <- cut_comp1(table_ts_comp[i,2])
  table_ts_comp[i,6] <- cut_comp2(table_ts_comp[i,2])
}

# Note: later in the code we will save 'table_ts_pcr' and 'table_ts_comp' in xlsx file with other model results

### Apply Thresholds to Predictions ###

# Extract selected optimum threshold values from ts_pcr
ts_pcr_rs0.8 <- as.data.frame(ts_pcr[5,])
ts_pcr_rs0.85 <- as.data.frame(ts_pcr[6,])
ts_pcr_rs0.9 <- as.data.frame(ts_pcr[7,])
ts_pcr_rs0.95 <- as.data.frame(ts_pcr[8,])
ts_pcr_mss3 <- as.data.frame(ts_pcr[2,])

ts_comp_rs0.8 <- as.data.frame(ts_comp[5,])
ts_comp_rs0.85 <- as.data.frame(ts_comp[6,])
ts_comp_rs0.9 <- as.data.frame(ts_comp[7,])
ts_comp_rs0.95 <- as.data.frame(ts_comp[8,])
ts_comp_mss3 <- as.data.frame(ts_comp[2,])

# Threshold the results to binary outputs
pred %>%
  mutate(bin_pcr_rs0.8 = ifelse(pred_pcr > ts_pcr_rs0.8$pred_pcr, 1, 0),
         bin_pcr_rs0.85 = ifelse(pred_pcr > ts_pcr_rs0.85$pred_pcr, 1, 0),
         bin_pcr_rs0.9 = ifelse(pred_pcr > ts_pcr_rs0.9$pred_pcr, 1, 0),
         bin_pcr_rs0.95 = ifelse(pred_pcr > ts_pcr_rs0.95$pred_pcr, 1, 0),
         bin_pcr_mss3 = ifelse(pred_pcr > ts_pcr_mss3$pred_pcr, 1, 0),
         bin_comp_rs0.8 = ifelse(pred_comp > ts_comp_rs0.8$pred_comp, 1, 0),
         bin_comp_rs0.85 = ifelse(pred_comp > ts_comp_rs0.85$pred_comp, 1, 0),
         bin_comp_rs0.9 = ifelse(pred_comp > ts_comp_rs0.9$pred_comp, 1, 0),
         bin_comp_rs0.95 = ifelse(pred_comp > ts_comp_rs0.95$pred_comp, 1, 0),
         bin_comp_mss3 = ifelse(pred_comp > ts_comp_mss3$pred_comp, 1, 0)) -> pred

# Pull out the relevant lists of predicted hosts based on various thresholds
pred %>% filter(PCR==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known_pcr 
pred %>% filter(bin_pcr_rs0.8==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr_rs0.8
pred %>% filter(bin_pcr_rs0.85==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr_rs0.85
pred %>% filter(bin_pcr_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr_rs0.9 
pred %>% filter(bin_pcr_rs0.95==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr_rs0.95
pred %>% filter(bin_pcr_mss3==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr_mss3 
pred %>% filter(competence==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known_comp 
pred %>% filter(bin_comp_rs0.8==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp_rs0.8
pred %>% filter(bin_comp_rs0.85==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp_rs0.85
pred %>% filter(bin_comp_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp_rs0.9
pred %>% filter(bin_comp_rs0.95==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp_rs0.95
pred %>% filter(bin_comp_mss3==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp_mss3 

# Sort and create dataframe of known and unknown hosts (hosts that do not overlap)
pred_kpcr <- as.data.frame(sort(known_pcr)) #n=58 
pred_upcr_rs0.8 <- as.data.frame(sort(pred_pcr_rs0.8[!(pred_pcr_rs0.8 %in% known_pcr)])) #n=69
pred_upcr_rs0.85 <- as.data.frame(sort(pred_pcr_rs0.8[!(pred_pcr_rs0.85 %in% known_pcr)])) 
pred_upcr_rs0.9 <- as.data.frame(sort(pred_pcr_rs0.9[!(pred_pcr_rs0.9 %in% known_pcr)])) 
pred_upcr_rs0.95 <- as.data.frame(sort(pred_pcr_rs0.95[!(pred_pcr_rs0.95 %in% known_pcr)]))
pred_upcr_mss3 <- as.data.frame(sort(pred_pcr_mss3[!(pred_pcr_mss3 %in% known_pcr)])) 
###note that known hosts include those predicted (n=47) and not predicted by the model (n=11) 

pred_kcomp <- as.data.frame(sort(known_comp)) #n=41
pred_ucomp_rs0.8 <- as.data.frame(sort(pred_comp_rs0.8[!(pred_comp_rs0.8 %in% known_comp)]))
pred_ucomp_rs0.85 <- as.data.frame(sort(pred_comp_rs0.8[!(pred_comp_rs0.85 %in% known_comp)]))
pred_ucomp_rs0.9 <- as.data.frame(sort(pred_comp_rs0.9[!(pred_comp_rs0.9 %in% known_comp)]))
pred_ucomp_rs0.95 <- as.data.frame(sort(pred_comp_rs0.95[!(pred_comp_rs0.95 %in% known_comp)]))
pred_ucomp_mss3 <- as.data.frame(sort(pred_comp_mss3[!(pred_comp_mss3 %in% known_comp)])) 

# How many predicted hosts are undiscovered by PCR?
nrow(pred_upcr_rs0.8)
nrow(pred_upcr_rs0.85)
nrow(pred_upcr_rs0.9)
nrow(pred_upcr_rs0.95)
nrow(pred_upcr_mss3)

# How many predicted undiscovered hosts by competence
nrow(pred_ucomp_rs0.8)
nrow(pred_ucomp_rs0.85)
nrow(pred_ucomp_rs0.9)
nrow(pred_ucomp_rs0.95)
nrow(pred_ucomp_mss3)

# To export as a single excel sheet, create list of dataframes/tables
list_df <- list(pred_kpcr, pred_upcr_rs0.8, pred_upcr_rs0.85, pred_upcr_rs0.9, pred_upcr_rs0.95, pred_upcr_mss3, pred_kcomp, pred_ucomp_rs0.8, pred_ucomp_rs0.85, pred_ucomp_rs0.9, pred_ucomp_rs0.95, pred_ucomp_mss3)

# Rename variables
list_df <- lapply(list_df, function(x) {colnames(x) <- c("gen"); x})

# Incorporate taxonomic family & order for each model
taxa <- apreds2_host[,c("genus","fam","ord")] 
taxa <- unique(taxa)
names(taxa)[names(taxa) == 'genus'] <- 'gen'
list_df <- lapply(list_df, function(x) {x <- merge(x, taxa, by = "gen", all=FALSE); x})

# Sort by virus, order, family, and genus
list_df <- lapply(list_df, function(x) {x <- x[order(x$ord, x$fam, x$gen),]; x})

# Reorder columns
list_df <- lapply(list_df, function(x) {x <- x[,c("ord","fam","gen")]; x})

# Reformat to proper
library(stringr)
list_df <- lapply(list_df, function(x) {x$fam <- str_to_title(x$fam); x})
list_df <- lapply(list_df, function(x) {x$ord <- str_to_title(x$ord); x})

# Unlist
pred_kpcr <- as.data.frame(list_df[[1]])
pred_upcr_rs0.8 <- as.data.frame(list_df[[2]])
pred_upcr_rs0.85 <- as.data.frame(list_df[[3]])
pred_upcr_rs0.9 <- as.data.frame(list_df[[4]])
pred_upcr_rs0.95 <- as.data.frame(list_df[[5]])
pred_upcr_mss3 <- as.data.frame(list_df[[6]])
pred_kcomp <- as.data.frame(list_df[[7]])
pred_ucomp_rs0.8 <- as.data.frame(list_df[[8]])
pred_ucomp_rs0.85 <- as.data.frame(list_df[[9]])
pred_ucomp_rs0.9 <- as.data.frame(list_df[[10]])
pred_ucomp_rs0.95 <- as.data.frame(list_df[[11]])
pred_ucomp_mss3 <- as.data.frame(list_df[[12]])

# Save for known hosts and unknown hosts where req.sens=0.8, req.sens=0.85, req.sens=0.9, req.sens=0.95, and opt.methods=3 (MaxSensSpec)
pred_pcr <- list('pcr_known'=pred_kpcr, 
                    'pcr_unknown_rs0.8'=pred_upcr_rs0.8, 
                    'pcr_unknown_rs0.85'=pred_upcr_rs0.85, 
                    'pcr_unknown_rs0.9'=pred_upcr_rs0.9, 
                    'pcr_unknown_rs0.95'=pred_upcr_rs0.95, 
                    'pcr_unknown_mss3'=pred_upcr_mss3)
pred_comp <- list('comp_known'=pred_kcomp, 
                    'comp_unknown_rs0.8'=pred_ucomp_rs0.8,
                    'comp_unknown_rs0.85'=pred_ucomp_rs0.85,
                    'comp_unknown_rs0.9'=pred_ucomp_rs0.9,
                    'comp_unknown_rs0.95'=pred_ucomp_rs0.95, 
                    'comp_unknown_mss3'=pred_ucomp_mss3)
write.xlsx(pred_pcr, file='figures/other/hosttrait/table_binarypredictions_pcr.xlsx')
write.xlsx(pred_comp, file='figures/other/hosttrait/table_binarypredictions_comp.xlsx')

###########################################################################
### Extract Binary Predictions for Model 1 ###
###########################################################################

### Calculate Threshold Values ###

# Load predictions for Model 1
pred1 <- read_excel("figures/other/linkpred/table_predprobs_link.xlsx", sheet = "model1")
pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)

# Create table of optimal threshold values for 5 different methods
ts1 <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(2,3,4,5,10), 
                           req.sens = 0.80,
                           na.rm = TRUE)
  #opt.methods=2: Sens=Spec = 0.0385000
  #opt.methods=3: MaxSens+Spec = 0.0597000
  #opt.methods=4: MaxKappa = 0.4949000 (Th that gives max value of Kappa - assess improvement over chance prediction)
  #opt.methods=5: MaxPCC = 0.5670222 (Th that maximizes total accuracy or Percent Correctly Classified)
  #opt.methods=10: ReqSens = 0.0365000 (set required sensitivity - req.sens)

# Add method applying 85% required sensitivity
ts1[nrow(ts1) + 1,] <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.85,
                           na.rm = TRUE)

# Add method applying 90% required sensitivity
ts1[nrow(ts1) + 1,] <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.9,
                           na.rm = TRUE)

# Add method applying 95% required sensitivity
ts1[nrow(ts1) + 1,] <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.95,
                           na.rm = TRUE)

# Create function that sums the number of predicted obs (known and unknown) and just unknown obs predicted as links based on calculated THVs for Model 1; use sapply to view counts
cut.1 <- function(x) {sum(pred1$pred_Model1 > x)}  #all predicted links
cut.2 <- function(x) {sum(pred1$pred_Model1[pred1$link1==0] > x)}  #unknown predicted links only
sapply(unlist(ts1[2]), cut.1) #number of predicted links
sapply(unlist(ts1[2]), cut.2) #number of unknown predicted links
sum(pred1$link1)

### Create Table of Optimal Thresholding Methods, Values, and Number of Predicted Hosts ###

# Save threshold values as new tables
table_ts1 <- ts1

# Correct method labels
table_ts1[5,1] <- "ReqSens 80%"
table_ts1[6,1] <- "ReqSens 85%"
table_ts1[7,1] <- "ReqSens 90%"
table_ts1[8,1] <- "ReqSens 95%"

# Add new columns for sensitivity, specificity, number of predicted hosts, and number of unknown predicted hosts
table_ts1$threshold <- table_ts1$pred_Model1
table_ts1$pred_Model1 <- NULL
table_ts1$sensitivity <- NA
table_ts1$specificity <- NA
table_ts1$n_predicted <- NA
table_ts1$n_predicted_unknown <- NA

# Get sensitivity, specificity, and number of predicted hosts based on various threshold values
for (i in 1:nrow(table_ts1)) {
  table_ts1[i,3] <-  InformationValue::sensitivity(pred1$link1, pred1$pred_Model1, threshold = table_ts1[i,2])
  table_ts1[i,4] <-  InformationValue::specificity(pred1$link1, pred1$pred_Model1, threshold = table_ts1[i,2])
  table_ts1[i,5] <- cut.1(table_ts1[i,2])
  table_ts1[i,6] <- cut.2(table_ts1[i,2])
}

# Note: later in the code we will save 'table_ts1' as xlsx file with other model results

### Apply Thresholds to Predictions ###

# Extract selected optimum threshold values from ts.1
ts1_rs0.8 <- as.data.frame(ts1[5,])
ts1_rs0.85 <- as.data.frame(ts1[6,])
ts1_rs0.9 <- as.data.frame(ts1[7,])
ts1_rs0.95 <- as.data.frame(ts1[8,])
ts1_mss3 <- as.data.frame(ts1[2,])

# Extract lists of known and unknown predicted hosts applying different thresholds
  pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)
  
# Threshold the results to binary outputs
  pred1 %>%
    mutate(bin_rs0.8 = ifelse(pred_Model1 > ts1_rs0.8$pred_Model1, 1, 0),
           bin_rs0.85 = ifelse(pred_Model1 > ts1_rs0.85$pred_Model1, 1, 0),
           bin_rs0.9 = ifelse(pred_Model1 > ts1_rs0.9$pred_Model1, 1, 0),
           bin_mss3 = ifelse(pred_Model1 > ts1_mss3$pred_Model1,1,0)) -> pred1
  
# Pull out the relevant lists 
pred1 %>% filter(link1==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> known
pred1 %>% filter(bin_rs0.8==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.8
pred1 %>% filter(bin_rs0.85==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.85
pred1 %>% filter(bin_rs0.9==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.9
pred1 %>% filter(bin_mss3==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_mss3

# Sort and create table of known and unknown hosts (hosts that do not overlap)
pred_kn <- as.data.frame(sort(known))
pred_unk_rs0.8 <- as.data.frame(sort(pred_rs0.8[!(pred_rs0.8 %in% known)])) #n=421
pred_unk_rs0.85 <- as.data.frame(sort(pred_rs0.85[!(pred_rs0.85 %in% known)])) #n=1149
pred_unk_rs0.9 <- as.data.frame(sort(pred_rs0.9[!(pred_rs0.9 %in% known)])) #n=1700
pred_unk_mss3 <- as.data.frame(sort(pred_mss3[!(pred_mss3 %in% known)])) #n=1358

  # How many predicted hosts are undiscovered by Model 1?
  nrow(pred_unk_rs0.8) 
  nrow(pred_unk_rs0.85)
  nrow(pred_unk_rs0.9) 
  nrow(pred_unk_mss3) 

# Rename variables
colnames(pred_kn) <- c("V1")
colnames(pred_unk_rs0.8) <- c("V1")
colnames(pred_unk_rs0.85) <- c("V1")
colnames(pred_unk_rs0.9) <- c("V1")
colnames(pred_unk_mss3) <- c("V1")

# Create list of dataframes/tables
list_df <- list(pred_kn, pred_unk_rs0.8, pred_unk_rs0.85, pred_unk_rs0.9, pred_unk_mss3)

# Extract virus as a separate column
list_df <- lapply(list_df, function(x) {x$virus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[1],sep=' ')); x})

# Extract genus as a separate column
list_df <- lapply(list_df, function(x) {x$genus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[2],sep=' ')); x})

# Clean up
list_df <- lapply(list_df, function(x) {x$V1=NULL; x})

# Incorporate taxonomic family & order for each model
taxa <- apreds2_link[,c("genus","fam","ord")] 
taxa <- unique(taxa)
list_df <- lapply(list_df, function(x) {x <- merge(x, taxa, by = "genus", all=FALSE); x})

# Sort by virus, order, family, and genus
list_df <- lapply(list_df, function(x) {x <- x[order(x$virus, x$ord, x$fam, x$genus),]; x})

# Reorder columns
list_df <- lapply(list_df, function(x) {x <- x[,c("virus","ord","fam","genus")]; x})

# Reformat to proper
list_df <- lapply(list_df, function(x) {x$fam <- str_to_title(x$fam); x})
list_df <- lapply(list_df, function(x) {x$ord <- str_to_title(x$ord); x})

# Unlist
pred_kn <- as.data.frame(list_df[[1]])
pred_unk_rs0.8 <- as.data.frame(list_df[[2]])
pred_unk_rs0.85 <- as.data.frame(list_df[[3]])
pred_unk_rs0.9 <- as.data.frame(list_df[[4]])
pred_unk_mss3 <- as.data.frame(list_df[[5]])

# Save for known hosts and unknown hosts where req.sens=0.8, req.sens=0.85, req.sens=0.9, and opt.methods=3 (MaxSensSpec)
pred_model1 <- list('known'=pred_kn, 
                    'unknown_rs0.8'=pred_unk_rs0.8, 
                    'unknown_rs0.85'=pred_unk_rs0.85, 
                    'unknown_rs0.9'=pred_unk_rs0.9, 
                    'unknown_mss3'=pred_unk_mss3)
write.xlsx(pred_model1, file='figures/other/linkpred/table_binarypredictions_model1.xlsx')

# Let's analyze the ratio of unknown predicted hosts to known hosts
list_virus <- list_df
list_virus <- lapply(list_virus, function(x) {x$link <- 1; x})
list_virus <- lapply(list_virus, function(x) {x <- aggregate(link ~ virus, data=x, FUN=sum); x})
known <- list_virus[[1]]$link
list_virus <- lapply(list_virus, function(x) {x <- cbind(x, known); x})
list_virus <- lapply(list_virus, function(x) {x$sum <- x$link+x$known; x})
list_virus <- lapply(list_virus, function(x) {x$ratio_sum_to_known <- x$sum/x$known; x})
list_virus <- lapply(list_virus, function(x) {x$opv_ratio <- sum(x$sum)/sum(x$known); x})

virus_ratio_rs0.8 <- as.data.frame(list_virus[[2]])
virus_ratio_rs0.85 <- as.data.frame(list_virus[[3]])
virus_ratio_rs0.9 <- as.data.frame(list_virus[[4]])
virus_ratio_mss0.3 <- as.data.frame(list_virus[[5]])

# Save as excel sheets
library(openxlsx)
virus_ratio_model1 <- list('rs0.8'=virus_ratio_rs0.8, 
                           'rs0.85'=virus_ratio_rs0.85,
                           'rs0.9'=virus_ratio_rs0.9, 
                           'mss0.3' = virus_ratio_mss0.3)
write.xlsx(virus_ratio_model1, file = 'figures/other/linkpred/table_virusratio_model1.xlsx')

###########################################################################
### Extract Binary Predictions for Model 2 ###
###########################################################################

### Calculate Threshold Values ###

# Load file
pred2 <- read_excel("figures/other/linkpred/table_predprobs_link.xlsx", sheet = "model2")
pred2$virus_treename=paste0(pred2$virus, "%",pred2$treename)

# Remove NA vaccinia values
pred2 <- pred2[which(!is.na(pred2$link2)),]

# Create table of optimal threshold values for 5 different methods
ts2 <- optimal.thresholds(data.frame(pred2[,c('virus_treename','link2','pred_Model2')]),
                           threshold = 10001,
                           opt.methods = c(2,3,4,5,10),
                           req.sens = 0.80,
                           na.rm = TRUE)

# Add method applying 85% required sensitivity
ts2[nrow(ts2) + 1,] <- optimal.thresholds(data.frame(pred2[,c('virus_treename','link2','pred_Model2')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.85,
                           na.rm = TRUE)

# Add method applying 90% required sensitivity
ts2[nrow(ts2) + 1,] <- optimal.thresholds(data.frame(pred2[,c('virus_treename','link2','pred_Model2')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.9,
                           na.rm = TRUE)

# Add method applying 95% required sensitivity
ts2[nrow(ts2) + 1,] <- optimal.thresholds(data.frame(pred2[,c('virus_treename','link2','pred_Model2')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.95,
                           na.rm = TRUE)

# Create function that sums the number of unknown obs predicted as links based on calculated THVs for Model 2
cut.2 <- function(x) {sum(pred2$pred_Model2[pred2$link2==0] > x)}

# Apply cut function using THVs from ts.2 and from prior calculated THVs for Model 2 to view number of number of obs with previously undetected links having predicted probabilities greater than the optimum threshold value
sapply(unlist(ts2[2]), cut.2)

### Create Table of Optimal Thresholding Methods, Values, and Number of Predicted Hosts ###

# Save threshold values as new tables
table_ts2 <- ts2

# Correct method labels
table_ts2[5,1] <- "ReqSens 80%"
table_ts2[6,1] <- "ReqSens 85%"
table_ts2[7,1] <- "ReqSens 90%"
table_ts2[8,1] <- "ReqSens 95%"

# Add new columns for sensitivity, specificity, number of predicted hosts, and number of unknown predicted hosts
table_ts2$threshold <- table_ts2$pred_Model2
table_ts2$pred_Model2 <- NULL
table_ts2$sensitivity <- NA
table_ts2$specificity <- NA
table_ts2$n_predicted <- NA
table_ts2$n_predicted_unknown <- NA

# Get sensitivity, specificity, and number of predicted hosts based on various threshold values
for (i in 1:nrow(table_ts2)) {
  table_ts2[i,3] <-  InformationValue::sensitivity(pred2$link2, pred2$pred_Model2, threshold = table_ts2[i,2])
  table_ts2[i,4] <-  InformationValue::specificity(pred2$link2, pred2$pred_Model2, threshold = table_ts2[i,2])
  table_ts2[i,5] <- cut.1(table_ts2[i,2])
  table_ts2[i,6] <- cut.2(table_ts2[i,2])
}

# Note: later in the code we will save 'table_ts2' as xlsx file with other model results

### Apply Thresholds to Predictions ###

# Extract selected optimum threshold values from ts.2
ts2_rs0.8 <- as.data.frame(ts2[5,])
ts2_rs0.85 <- as.data.frame(ts2[6,])
ts2_rs0.9 <- as.data.frame(ts2[7,])
ts2_rs0.95 <- as.data.frame(ts2)
ts2_ses2 <- as.data.frame(ts2[1,])
ts2_mss3 <- as.data.frame(ts2[2,])

# Extract lists of known and unknown predicted hosts applying different thresholds
pred2$virus_treename=paste0(pred2$virus, "%",pred2$treename)
  
  # Threshold the results to binary outputs
  pred2 %>%
    mutate(bin_rs0.8 = ifelse(pred_Model2 > ts2_rs0.8$pred_Model2, 1, 0),
           bin_rs0.85 = ifelse(pred_Model2 > ts2_rs0.85$pred_Model2, 1, 0),
           bin_rs0.9 = ifelse(pred_Model2 > ts2_rs0.9$pred_Model2, 1, 0),
           bin_mss3 = ifelse(pred_Model2 > ts2_mss3$pred_Model2,1,0)) -> pred2

# Pull out the relevant lists 
pred2 %>% filter(link2==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> known
pred2 %>% filter(bin_rs0.8==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.8
pred2 %>% filter(bin_rs0.85==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.85
pred2 %>% filter(bin_rs0.9==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.9
pred2 %>% filter(bin_mss3==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_mss3

# Sort and create table of known and unknown hosts (hosts that do not overlap)
pred_kn <- as.data.frame(sort(known))
pred_unk_rs0.8 <- as.data.frame(sort(pred_rs0.8[!(pred_rs0.8 %in% known)])) #n=475
pred_unk_rs0.85 <- as.data.frame(sort(pred_rs0.85[!(pred_rs0.85 %in% known)])) #n=1034
pred_unk_rs0.9 <- as.data.frame(sort(pred_rs0.9[!(pred_rs0.9 %in% known)])) #n=2635
pred_unk_mss3 <- as.data.frame(sort(pred_mss3[!(pred_mss3 %in% known)])) #n=1364

  # How many predicted hosts are undiscovered by Model 2?
  nrow(pred_unk_rs0.8) 
  nrow(pred_unk_rs0.85)
  nrow(pred_unk_rs0.9) 
  nrow(pred_unk_mss3) 

# Rename variables
colnames(pred_kn) <- c("V1")
colnames(pred_unk_rs0.8) <- c("V1")
colnames(pred_unk_rs0.85) <- c("V1")
colnames(pred_unk_rs0.9) <- c("V1")
colnames(pred_unk_mss3) <- c("V1")

# Create list of dataframes/tables
list_df <- list(pred_kn, pred_unk_rs0.8, pred_unk_rs0.85, pred_unk_rs0.9, pred_unk_mss3)

# Extract virus as a separate column
list_df <- lapply(list_df, function(x) {x$virus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[1],sep=' ')); x})

# Extract genus as a separate column
list_df <- lapply(list_df, function(x) {x$genus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[2],sep=' ')); x})

# Clean up
list_df <- lapply(list_df, function(x) {x$V1=NULL; x})

# Incorporate taxonomic family & order for each model
taxa <- apreds2_link[,c("genus","fam","ord")] 
taxa <- unique(taxa)
list_df <- lapply(list_df, function(x) {x <- merge(x, taxa, by = "genus", all=FALSE); x})

# Sort by virus, order, family, and genus
list_df <- lapply(list_df, function(x) {x <- x[order(x$virus, x$ord, x$fam, x$genus),]; x})

# Reorder columns
list_df <- lapply(list_df, function(x) {x <- x[,c("virus","ord","fam","genus")]; x})

# Reformat to proper
list_df <- lapply(list_df, function(x) {x$fam <- str_to_title(x$fam); x})
list_df <- lapply(list_df, function(x) {x$ord <- str_to_title(x$ord); x})

# Unlist
pred_kn <- as.data.frame(list_df[[1]])
pred_unk_rs0.8 <- as.data.frame(list_df[[2]])
pred_unk_rs0.85 <- as.data.frame(list_df[[3]])
pred_unk_rs0.9 <- as.data.frame(list_df[[4]])
pred_unk_mss3 <- as.data.frame(list_df[[5]])

# Save for known hosts and unknown hosts where req.sens=0.8, req.sens=0.85, req.sens=0.9, and opt.methods=3 (MaxSensSpec)
pred_model2 <- list('known'=pred_kn, 
                    'unknown_rs0.8'=pred_unk_rs0.8, 
                    'unknown_rs0.85'=pred_unk_rs0.85, 
                    'unknown_rs0.9'=pred_unk_rs0.9, 
                    'unknown_mss3'=pred_unk_mss3)
write.xlsx(pred_model2, file='figures/other/linkpred/table_binarypredictions_model2.xlsx')

# Let's analyze the ratio of unknown predicted hosts to known hosts
list_virus <- list_df
list_virus <- lapply(list_virus, function(x) {x$link <- 1; x})
list_virus <- lapply(list_virus, function(x) {x <- aggregate(link ~ virus, data=x, FUN=sum); x})
known <- list_virus[[1]]$link
list_virus <- lapply(list_virus, function(x) {x <- cbind(x, known); x})
list_virus <- lapply(list_virus, function(x) {x$sum <- x$link+x$known; x})
list_virus <- lapply(list_virus, function(x) {x$ratio_sum_to_known <- x$sum/x$known; x})
list_virus <- lapply(list_virus, function(x) {x$opv_ratio <- sum(x$sum)/sum(x$known); x})

virus_ratio_rs0.8 <- as.data.frame(list_virus[[2]])
virus_ratio_rs0.85 <- as.data.frame(list_virus[[3]])
virus_ratio_rs0.9 <- as.data.frame(list_virus[[4]])
virus_ratio_mss0.3 <- as.data.frame(list_virus[[5]])

# Save as excel sheets
virus_ratio_model2 <- list('rs0.8' = virus_ratio_rs0.8,
                           'rs0.85' = virus_ratio_rs0.85,
                           'rs0.9' = virus_ratio_rs0.9, 
                           'mss0.3' = virus_ratio_mss0.3)
write.xlsx(virus_ratio_model2, file = 'figures/other/linkpred/table_virusratio_model2.xlsx')


###########################################################################
### Extract Binary Predictions for Model 3 ###
###########################################################################

### Calculate Threshold Values ###

# Load file
pred3 <- read_excel("figures/other/linkpred/table_predprobs_link.xlsx", sheet = "model3")
pred3$virus_treename=paste0(pred3$virus, "%",pred3$treename)

# Create table of optimal threshold values for 5 different methods
ts3 <- optimal.thresholds(data.frame(pred3[,c('virus_treename','link3','pred_Model3')]),
                           threshold = 10001,
                           opt.methods = c(2,3,4,5,10),
                           req.sens = 0.80,
                           na.rm = TRUE)

# Add method applying 85% required sensitivity
ts3[nrow(ts3) + 1,] <- optimal.thresholds(data.frame(pred3[,c('virus_treename','link3','pred_Model3')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.85,
                           na.rm = TRUE)

# Add method applying 90% required sensitivity
ts3[nrow(ts3) + 1,] <- optimal.thresholds(data.frame(pred3[,c('virus_treename','link3','pred_Model3')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.9,
                           na.rm = TRUE)

# Add method applying 95% required sensitivity
ts3[nrow(ts3) + 1,] <- optimal.thresholds(data.frame(pred3[,c('virus_treename','link3','pred_Model3')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.95,
                           na.rm = TRUE)

# Create function that sums the number of unknown obs predicted as links based on calculated THVs for Model 2
cut.3 <- function(x) {sum(pred3$pred_Model3[pred3$link3==0] > x)}

# Apply cut function using THVs from ts.3 and from prior calculated THVs for Model 3 to view number of number of obs with previously undetected links having predicted probabilities greater than the optimum threshold value
sapply(unlist(ts3[2]), cut.3)

### Create Table of Optimal Thresholding Methods, Values, and Number of Predicted Hosts ###

# Save threshold values as new tables
table_ts3 <- ts3

# Correct method labels
table_ts3[5,1] <- "ReqSens 80%"
table_ts3[6,1] <- "ReqSens 85%"
table_ts3[7,1] <- "ReqSens 90%"
table_ts3[8,1] <- "ReqSens 95%"

# Add new columns for sensitivity, specificity, number of predicted hosts, and number of unknown predicted hosts
table_ts3$threshold <- table_ts3$pred_Model3
table_ts3$pred_Model3 <- NULL
table_ts3$sensitivity <- NA
table_ts3$specificity <- NA
table_ts3$n_predicted <- NA
table_ts3$n_predicted_unknown <- NA

# Get sensitivity, specificity, and number of predicted hosts based on various threshold values
for (i in 1:nrow(table_ts3)) {
  table_ts3[i,3] <-  InformationValue::sensitivity(pred3$link3, pred3$pred_Model3, threshold = table_ts3[i,2])
  table_ts3[i,4] <-  InformationValue::specificity(pred3$link3, pred3$pred_Model3, threshold = table_ts3[i,2])
  table_ts3[i,5] <- cut.1(table_ts3[i,2])
  table_ts3[i,6] <- cut.2(table_ts3[i,2])
}

# Create list of tables of the effects of threshold moving for all models and save as supp figure 5
table_ts <- list("pcr" = table_ts_pcr, 
                 "comp" = table_ts_comp,
                 "model1" = table_ts1, 
                 "model2" = table_ts2, 
                 "model3" = table_ts3)
write.xlsx(table_ts, file = "figures/supplementary/s5table_thresholdmoving.xlsx")

### Apply Thresholds to Predictions ###

# Extract selected optimum threshold values from ts.3
ts3_rs0.8 <- as.data.frame(ts3[5,])
ts3_rs0.85 <- as.data.frame(ts3[6,])
ts3_rs0.9 <- as.data.frame(ts3[7,])
ts3_rs0.95 <- as.data.frame(ts3)
ts3_ses2 <- as.data.frame(ts3[1,])
ts3_mss3 <- as.data.frame(ts3[2,])

# Extract lists of known and unknown predicted hosts applying different thresholds
pred3$virus_treename=paste0(pred3$virus, "%",pred3$treename)
  
  # Threshold the results to binary outputs
  pred3 %>%
    mutate(bin_rs0.8 = ifelse(pred_Model3 > ts3_rs0.8$pred_Model3, 1, 0),
           bin_rs0.85 = ifelse(pred_Model3 > ts3_rs0.85$pred_Model3, 1, 0),
           bin_rs0.9 = ifelse(pred_Model3 > ts3_rs0.9$pred_Model3, 1, 0),
           bin_mss3 = ifelse(pred_Model3 > ts3_mss3$pred_Model3,1,0)) -> pred3

# Pull out the relevant lists 
pred3 %>% filter(link3==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> known
pred3 %>% filter(bin_rs0.8==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.8
pred3 %>% filter(bin_rs0.85==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.85
pred3 %>% filter(bin_rs0.9==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_rs0.9
pred3 %>% filter(bin_mss3==1) %>% dplyr::pull(virus_treename) %>% gsub("_"," ",.) -> pred_mss3

# Sort and create table of known and unknown hosts (hosts that do not overlap)
pred_kn <- as.data.frame(sort(known))
pred_unk_rs0.8 <- as.data.frame(sort(pred_rs0.8[!(pred_rs0.8 %in% known)])) #n=7948
pred_unk_rs0.85 <- as.data.frame(sort(pred_rs0.85[!(pred_rs0.85 %in% known)])) #n=7948
pred_unk_rs0.9 <- as.data.frame(sort(pred_rs0.9[!(pred_rs0.9 %in% known)])) #n=8554
pred_unk_mss3 <- as.data.frame(sort(pred_mss3[!(pred_mss3 %in% known)])) #n=2011

  # How many predicted hosts are undiscovered by Model 2?
  nrow(pred_unk_rs0.8) 
  nrow(pred_unk_rs0.85)
  nrow(pred_unk_rs0.9) 
  nrow(pred_unk_mss3) 

# Rename variables
colnames(pred_kn) <- c("V1")
colnames(pred_unk_rs0.8) <- c("V1")
colnames(pred_unk_rs0.85) <- c("V1")
colnames(pred_unk_rs0.9) <- c("V1")
colnames(pred_unk_mss3) <- c("V1")

# Create list of dataframes/tables
list_df <- list(pred_kn, pred_unk_rs0.8, pred_unk_rs0.85, pred_unk_rs0.9, pred_unk_mss3)

# Extract virus as a separate column
list_df <- lapply(list_df, function(x) {x$virus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[1],sep=' ')); x})

# Extract genus as a separate column
list_df <- lapply(list_df, function(x) {x$genus <- sapply(strsplit(x$V1,'%'),function(x) paste(x[2],sep=' ')); x})

# Clean up
list_df <- lapply(list_df, function(x) {x$V1=NULL; x})

# Incorporate taxonomic family & order for each model
taxa <- apreds2[,c("genus","fam","ord")] 
taxa <- unique(taxa)
list_df <- lapply(list_df, function(x) {x <- merge(x, taxa, by = "genus", all=FALSE); x})

# Sort by virus, order, family, and genus
list_df <- lapply(list_df, function(x) {x <- x[order(x$virus, x$ord, x$fam, x$genus),]; x})

# Reorder columns
list_df <- lapply(list_df, function(x) {x <- x[,c("virus","ord","fam","genus")]; x})

# Reformat to proper
list_df <- lapply(list_df, function(x) {x$fam <- str_to_title(x$fam); x})
list_df <- lapply(list_df, function(x) {x$ord <- str_to_title(x$ord); x})

# Unlist
pred_kn <- as.data.frame(list_df[[1]])
pred_unk_rs0.8 <- as.data.frame(list_df[[2]])
pred_unk_rs0.85 <- as.data.frame(list_df[[3]])
pred_unk_rs0.9 <- as.data.frame(list_df[[4]])
pred_unk_mss3 <- as.data.frame(list_df[[5]])

# Save for known hosts and unknown hosts where req.sens=0.8, req.sens=0.85, req.sens=0.9, and opt.methods=3 (MaxSensSpec)
pred_model3 <- list('known'=pred_kn, 
                    'unknown_rs0.8'=pred_unk_rs0.8, 
                    'unknown_rs0.85'=pred_unk_rs0.85, 
                    'unknown_rs0.9'=pred_unk_rs0.9, 
                    'unknown_mss3'=pred_unk_mss3)
write.xlsx(pred_model3, file='figures/table_binarypredictions_model3.xlsx')

# Let's analyze the ratio of unknown predicted hosts to known hosts
list_virus <- list_df
list_virus <- lapply(list_virus, function(x) {x$link <- 1; x})
list_virus <- lapply(list_virus, function(x) {x <- aggregate(link ~ virus, data=x, FUN=sum); x})
known <- list_virus[[1]]$link
list_virus <- lapply(list_virus, function(x) {x <- cbind(x, known); x})
list_virus <- lapply(list_virus, function(x) {x$sum <- x$link+x$known; x})
list_virus <- lapply(list_virus, function(x) {x$ratio_sum_to_known <- x$sum/x$known; x})
list_virus <- lapply(list_virus, function(x) {x$opv_ratio <- sum(x$sum)/sum(x$known); x})

virus_ratio_rs0.8 <- as.data.frame(list_virus[[2]])
virus_ratio_rs0.85 <- as.data.frame(list_virus[[3]])
virus_ratio_rs0.9 <- as.data.frame(list_virus[[4]])
virus_ratio_mss0.3 <- as.data.frame(list_virus[[5]])

# Save as excel sheets
virus_ratio_model3 <- list('rs0.8' = virus_ratio_rs0.8,
                           'rs0.85' = virus_ratio_rs0.85,
                           'rs0.9' = virus_ratio_rs0.9, 
                           'mss0.3' = virus_ratio_mss0.3)
write.xlsx(virus_ratio_model3, file = 'figures/table_virusratio_model3.xlsx')

```

### *Explore model correlation and phylogenetic signal*

```{r pred_phylo}

### Test Correlation Between the Predicted Probabilities of Models ###

# host trait models (pcr vs. competence)
cor(apreds2_host$pred_pcr,apreds2_host$pred_comp,method='spearman') #computes Spearman correlation coefficient
cor.test(apreds2_host$pred_pcr,apreds2_host$pred_comp,method='spearman') #tests for correlation b/w paired samples based on Spearman corr test

# model 1 vs. model 2
cor(apreds2_link$pred_Model1,apreds2_link$pred_Model2,method='spearman') #computes Spearman correlation coefficient
cor.test(apreds2_link$pred_Model1,apreds2_link$pred_Model2,method='spearman') #tests for correlation b/w paired samples based on Spearman corr test
## The predicted probabilities of the BRT models including vs. excluding vaccinia virus links (Model 1 vs. Model 2) were significantly correlated.

# model 1 vs. model 3
cor(apreds2_link$pred_Model1,apreds2_link$pred_Model3,method='spearman') #computes Spearman correlation coefficient
cor.test(apreds2_link$pred_Model1,apreds2_link$pred_Model3,method='spearman') #tests for correlation b/w paired samples 

### Measure Phylogenetic Signal for Host Trait Models ###

# load phylogeny
load("data/hosttrait_cleandata.RData")
mtree=hostTree

# label observations in apreds2_host that are non-existent in mtree
apreds2_host$tree=ifelse(apreds2_host$treename%in%setdiff(apreds2_host$treename,mtree$tip.label),'cut','keep')
table(apreds2_host$tree) ## keep: 946

# trim and match
bdata=subset(apreds2_host,tree=='keep')
bdata=bdata[match(mtree$tip.label,bdata$treename),]

# save
bdata$label=bdata$treename
bdata$Species=bdata$treename

# generate mean of pcr and comp predicted probabilities
bdata <- bdata %>% dplyr::mutate(pred_mean = rowMeans(dplyr::across(pred_pcr:pred_comp), na.rm = TRUE))

# generate variable of whether OPV positivity was predicted based on threshold value
bdata$pcr_rs0.8 <- ifelse(bdata$pred_pcr > ts_pcr_rs0.8$pred_pcr, 1, 0)
bdata$comp_rs0.8 <- ifelse(bdata$pred_comp > ts_comp_rs0.8$pred_comp, 1, 0)
bdata$pcrcomp_rs0.8 <- ifelse(bdata$pcr_rs0.8==1 & bdata$comp_rs0.8==1, "Both",
                              ifelse(bdata$pcr_rs0.8==1 & bdata$comp_rs0.8==0, "PCR",
                                     ifelse(bdata$pcr_rs0.8==0 & bdata$comp_rs0.8==1, "Virus isolation", "Not predicted")))
bdata$pcr_mss3 <- ifelse(bdata$pred_pcr > ts_pcr_mss3$pred_pcr, 1, 0)
bdata$comp_mss3 <- ifelse(bdata$pred_comp > ts_comp_mss3$pred_comp, 1, 0)
bdata$pcrcomp_mss3 <- ifelse(bdata$pcr_mss3==1 & bdata$comp_mss3==1, "Both",
                              ifelse(bdata$pcr_mss3==1 & bdata$comp_mss3==0, "PCR",
                                     ifelse(bdata$pcr_mss3==0 & bdata$comp_mss3==1, "Virus isolation", "Not predicted")))

# make factor
bdata$pcrcomp_rs0.8 <- factor(bdata$pcrcomp_rs0.8,levels=c("PCR","Virus isolation","Both","Not predicted"))
bdata$pcrcomp_mss3 <- factor(bdata$pcrcomp_mss3,levels=c("PCR","Virus isolation","Both","Not predicted"))

# check for rows that are NA
which(is.na(bdata))

# # subsetting only non-missing data
# bdata_nonNA = bdata[which(!is.na(bdata)),]

# try merging again 
cdata_host=comparative.data(phy=mtree,data=bdata,names.col=treename,vcv=T,na.omit=T,warn.dropped=T)

# Fix
cdata_host$data$tree=NULL

# Measure phylogenetic signal (Pagel's lambda) of model predictions
pcr_lmod=pgls(pred_pcr~1,data=cdata_host,lambda="ML")     #pgls fits a linear model while taking into account phylogenetic non-independence between data points
comp_lmod=pgls(pred_comp~1,data=cdata_host,lambda="ML")   #lambda = value for lambda transformation; 'ML' uses maximum likelihood to optimize branch length transformations
###for more info: https://static1.squarespace.com/static/5459da8ae4b042d9849b7a7b/t/57ea64eae58c62718aa34769/1474979059782/Nesin_Winternitz_Practical_1and2.pdf

# Get Pagel's lambda (phylogenetic) 
summary(pcr_lmod)
summary(comp_lmod)

### Model Phylogenetic Signal for Link Prediction Models ###

#Load phylogeny
load("data/linkpred_cleandata.RData")
mtree=hostTree

# Label observations in apreds2 that are non-existent in mtree
apreds2_link$tree=ifelse(apreds2_link$treename%in%setdiff(apreds2_link$treename,mtree$tip.label),'cut','keep')
table(apreds2_link$tree)    
## keep: 17974

# Trim and match
bdata=subset(apreds2_link,tree=='keep')

#Save new vars
bdata$label=bdata$treename
bdata$Species=bdata$treename

#Generate variable of whether a link was predicted based on threshold value
bdata$link1_rs0.8 <- ifelse(bdata$pred_Model1 > ts1_rs0.8$pred_Model1, 1, 0)
bdata$link1_rs0.85 <- ifelse(bdata$pred_Model1 > ts1_rs0.85$pred_Model1, 1, 0)
bdata$link1_rs0.9 <- ifelse(bdata$pred_Model1 > ts1_rs0.9$pred_Model1, 1, 0)
bdata$link1_mss3 <- ifelse(bdata$pred_Model1 > ts1_mss3$pred_Model1, 1, 0)

#Aggregate at the host genera level across virus species; assume the mean b/c pgls() takes only one value per tip; aggregate separately for Model 1 and 2 predictions due to NA value for vaccinia virus in Model 2
bdata_mean_model1 <- aggregate(pred_Model1 ~ treename + ord + fam + genus + label + Species, data=bdata, mean)
bdata_mean_model2 <- aggregate(pred_Model2 ~ treename + ord + fam + genus + label + Species, data=bdata, mean)
bdata_mean_model3 <- aggregate(pred_Model3 ~ treename + ord + fam + genus + label + Species, data=bdata, mean)

# For visualizing binary classification of links on a phylogenetic tree (where only one tip value is allowed), we regroup as 'unclassified orthopoxvirus' the following virus species:
  # 'cetacean poxvirus 1'
  # 'cetacean poxvirus 2'
  # 'orthopoxvirus gcp2010'
  # 'orthopoxvirus gcp2013'
  # 'orthopoxvirus sp.'
  # 'orthopoxvirus tena dona'
  # 'steller sea lion poxvirus'

# Combine all rows of data for unclassified virus species into a single dataset
bdata_unclassified <- bdata[bdata$virus=="cetacean poxvirus 1",]
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="cetacean poxvirus 2",])
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="orthopoxvirus gcp2010",])
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="orthopoxvirus gcp2013",])
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="orthopoxvirus sp.",])
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="orthopoxvirus tena dona",])
bdata_unclassified <- rbind(bdata_unclassified, bdata[bdata$virus=="steller sea lion poxvirus",])

# Aggregate unclassified virus species at host genera level and take max value of link
bdata_unclassified <- aggregate(cbind(link1,link2,link3,link1_rs0.8,link1_rs0.85,link1_rs0.9,link1_mss3) ~ treename + ord + fam + genus + label + Species, data=bdata, max)

# Add virus column for "unclassified orthopoxvirus"
bdata_unclassified$virus <- "unclassified orthopoxvirus"

# Create new df bdata_sum from bdata to which we will append bdata_unclassified: match column names to those of bdata_unclassified, and drop virus species that were regrouped in unclassified
bdata_sum <- subset(bdata, select=c(colnames(bdata_unclassified)))
bdata_sum <- bdata_sum[!(bdata_sum$virus=="cetacean poxvirus 1"),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="cetacean poxvirus 2"),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="orthopoxvirus gcp2010"),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="orthopoxvirus gcp2013"),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="orthopoxvirus sp."),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="orthopoxvirus tena dona"),]
bdata_sum <- bdata_sum[!(bdata_sum$virus=="steller sea lion poxvirus"),]

# Append to bdata_sum new virus group of unclassified
bdata_sum <- rbind(bdata_sum, bdata_unclassified)

# Aggregate at the host genera level assuming the sum
bdata_sum <- aggregate(cbind(link1,link2,link1_rs0.8,link1_rs0.85,link1_rs0.9,link1_mss3) ~ treename + ord + fam + genus + label + Species, data=bdata_sum, sum)

# Combine bdata_mean and bdata_sum
bdata_agg <- merge(bdata_mean_model1, bdata_mean_model2, by=c("treename", "ord", "fam", "genus", "label", "Species"))
bdata_agg <- merge(bdata_agg, bdata_mean_model3, by=c("treename", "ord", "fam", "genus", "label", "Species"))
bdata_agg <- merge(bdata_agg, bdata_sum, by=c("treename", "ord", "fam", "genus", "label", "Species"))

### We take the mean of the predictions for visualizing the phylotree later b/c if the mean is >1 that means at least one host-virus link was positive within that host genera
### link1 and link2 represent known hosts; unknown_link1_ and unknown_link2_ represent unknown predicted hosts

# Merge tree data with predictions ensuring consistent structure
cdata_link=comparative.data(phy=mtree,data=bdata_agg,names.col=treename,vcv=T,na.omit=F,warn.dropped=T)  #vcv=T indicates to include variance covariance array representing phylogeny w/in the comparative dataset

# Fix
cdata_link$data$tree=NULL

# Measure phylogenetic signal (Pagel's lambda) of model predictions using caper::pgls
Model1_lmod=pgls(pred_Model1~1,data=cdata_link,lambda="ML")   #pgls fits a linear model while taking into account phylogenetic non-independence between data points
Model2_lmod=pgls(pred_Model2~1,data=cdata_link,lambda="ML")   #lambda = value for lambda transformation; 'ML' uses maximum likelihood to optimize branch length transformations
###for more info: https://static1.squarespace.com/static/5459da8ae4b042d9849b7a7b/t/57ea64eae58c62718aa34769/1474979059782/Nesin_Winternitz_Practical_1and2.pdf
Model3_lmod=pgls(pred_Model3~1,data=cdata_link,lambda="ML")

# Get Pagel's lambda (phylogenetic signal) 
summary(Model1_lmod)
summary(Model2_lmod)
summary(Model3_lmod)


```

### *Identify taxonomic patterns via phylofactorization*
Table: *tables2-s4_pfclades.csv*

```{r pred_pf}

# Holm rejection procedure (counteract the problem of multiple comparisons and controls for family-wise error rate)
HolmProcedure <- function(pf,FWER=0.05){
  
  ## get split variable
  cs=names(coef(pf$models[[1]]))[-1]
  split=ifelse(length(cs)>1,cs[3],cs[1])
  
  ## obtain p values
  if (pf$models[[1]]$family$family%in%c('gaussian',"Gamma","quasipoisson")){
    pvals <- sapply(pf$models,FUN=function(fit) summary(fit)$coefficients[split,'Pr(>|t|)'])
  } else {
    pvals <- sapply(pf$models,FUN=function(fit) summary(fit)$coefficients[split,'Pr(>|z|)'])
  }
  D <- length(pf$tree$tip.label)
  
  ## this is the line for Holm's sequentially rejective cutoff
  keepers <- pvals<=(FWER/(2*D-3 - 2*(0:(pf$nfactors-1))))
  
  
  if (!all(keepers)){
    nfactors <- min(which(!keepers))-1
  } else {
    nfactors <- pf$nfactors
  }
  return(nfactors)
}

# Get species in a clade
cladeget=function(pf,factor){
  spp=pf$tree$tip.label[pf$groups[[factor]][[1]]]
  return(spp)
}

# Summarize pf object 
pfsum=function(pf){
  
  ## get formula
  chars=as.character(pf$frmla.phylo)[-1]
  
  ## response
  resp=chars[1]
  
  ## fix
  resp=ifelse(resp=='cbind(pos, neg)','prevalence',resp)
  
  ## holm
  hp=HolmProcedure(pf)
  
  ## save model
  model=chars[2]
  
  ## set key
  setkey(pf$Data,'Species')
  
  ## make data
  dat=data.frame(pf$Data)
  
  ## make clade columns in data
  for(i in 1:hp){
    
    dat[,paste0(resp,'_pf',i)]=ifelse(dat$Species%in%cladeget(pf,i),'factor','other')
    
  }
  
  ## make data frame to store taxa name, response, mean, and other
  results=data.frame(matrix(ncol=6, nrow = hp))
  colnames(results)=c('factor','taxa','tips','node',"clade",'other')
  
  ## set taxonomy
  taxonomy=dat[c('Species','taxonomy')]
  taxonomy$taxonomy=as.character(taxonomy$taxonomy)
  
  ## loop
  for(i in 1:hp){
    
    ## get taxa
    tx=pf.taxa(pf,taxonomy,factor=i)$group1
    
    ## get tail
    tx=sapply(strsplit(tx,'; '),function(x) tail(x,1))
    
    ## combine
    tx=paste(tx,collapse=', ')
    
    # save
    results[i,'factor']=i
    results[i,'taxa']=tx
    
    ## get node
    tips=cladeget(pf,i)
    node=ggtree::MRCA(pf$tree,tips)
    results[i,'tips']=length(tips)
    results[i,'node']=ifelse(is.null(node) & length(tips)==1,'species',
                             ifelse(is.null(node) & length(tips)!=1,NA,node))
    
    ## get means
    ms=(tapply(dat[,resp],dat[,paste0(resp,'_pf',i)],mean))
    
    ## add in
    results[i,'clade']=ms['factor']
    results[i,'other']=ms['other']
    
  }
  
  ## return
  return(list(set=dat,results=results))
}

# Fix palette
AlberPalettes <- c("YlGnBu","Reds","BuPu", "PiYG")
AlberColours <- sapply(AlberPalettes, function(a) RColorBrewer::brewer.pal(5, a)[4])
afun=function(x){
  a=AlberColours[1:x]
  return(a)
}

# Make low and high
pcols=afun(2)

### Host Trait Models ###

# extract taxonomy
cdata_host$data$taxonomy=paste(cdata_host$data$ord,cdata_host$data$fam,cdata_host$data$Species,sep='; ') #We refer to genus as "Species" as this is required in later functions

# set taxonomy
taxonomy=data.frame(cdata_host$data$taxonomy)
names(taxonomy)="taxonomy"
taxonomy$Species=rownames(cdata_host$data)
taxonomy=taxonomy[c("Species","taxonomy")]
taxonomy$taxonomy=as.character(taxonomy$taxonomy)

# Generalized phylofactorization on PCR predictions
set.seed(1)
pcrpred_pf=gpf(Data=cdata_host$data,tree=cdata_host$phy,
               frmla.phylo=pred_pcr~phylo,
               family=gaussian,algorithm='phylo',nfactors=10,min.group.size=5)

# Generalized phylofactorization on competence predictions
set.seed(1)
comppred_pf=gpf(Data=cdata_host$data,tree=cdata_host$phy,
                frmla.phylo=pred_comp~phylo,
                family=gaussian,algorithm='phylo',nfactors=10,min.group.size=5)

# Summarize results of phylofactorization
pcrpred_pf_results=pfsum(pcrpred_pf)$results  # runs pfsum fxn on PCR predictions (pcrpred_pf); HolmProcedure is nested in pfsum
comppred_pf_results=pfsum(comppred_pf)$results

# Add model/evidence type variable 
pcrpred_pf_results$model="RT-PCR"
comppred_pf_results$model="virus isolation"

### Link Prediction Models ###

# Extract taxonomy
cdata_link$data$taxonomy=paste(cdata_link$data$ord,cdata_link$data$fam,cdata_link$data$Species,sep='; ') #We refer to genus as "Species" as this is required in later functions

# Set taxonomy
taxonomy=data.frame(cdata_link$data$taxonomy)
names(taxonomy)="taxonomy"
taxonomy$Species=rownames(cdata_link$data)
taxonomy=taxonomy[c("Species","taxonomy")]
taxonomy$taxonomy=as.character(taxonomy$taxonomy)

# Generalized phylofactorization on Model 1 predictions
set.seed(1)
Model1pred_pf=gpf(Data=cdata_link$data,tree=cdata_link$phy,
               frmla.phylo=pred_Model1~phylo,
               family=gaussian,algorithm='phylo',nfactors=20,min.group.size=5)

# Generalized phylofactorization on Model 2 predictions
set.seed(1)
Model2pred_pf=gpf(Data=cdata_link$data,tree=cdata_link$phy,
                frmla.phylo=pred_Model2~phylo,
                family=gaussian,algorithm='phylo',nfactors=10,min.group.size=5)

# Generalized phylofactorization on Model 3 predictions
set.seed(1)
Model3pred_pf=gpf(Data=cdata_link$data,tree=cdata_link$phy,
                frmla.phylo=pred_Model3~phylo,
                family=gaussian,algorithm='phylo',nfactors=10,min.group.size=5)

# Summarize results of phylofactorization
Model1pred_pf_results=pfsum(Model1pred_pf)$results
Model2pred_pf_results=pfsum(Model2pred_pf)$results
Model3pred_pf_results=pfsum(Model3pred_pf)$results

# Add model variable
Model1pred_pf_results$model="Model 1 (Full)"
Model2pred_pf_results$model="Model 2 (Partial)"
Model3pred_pf_results$model="Model 3 (Host traits only)"

# Combine results of all models

# Combine results of both models
predpfs=rbind.data.frame(pcrpred_pf_results,
                         comppred_pf_results, 
                         Model1pred_pf_results,
                         Model2pred_pf_results,
                         Model3pred_pf_results)

# Round probabilities to the 2nd decimal place
predpfs$clade=round(predpfs$clade,2)
predpfs$other=round(predpfs$other,2)

# Save as supp figures 2-4 
write.csv(predpfs,"figures/supplementary/s2-4table_pfclades.csv")

```

### *Plot predictions on phylogenetic tree*
For each model evidence type and various threshold values, we plot the predicted probabilities of mammal genera as geom segments corresponding to the tips of a circular mammal tree; colored segments correspond to host positivity 
Figures: *fig2_tree_pcr.png*, *s1fig_tree_comp.png*, *fig2_tree_model1.png*

```{r pred_tree1}

### Host Trait Models ###

# summarize distribution of predicted probabilities 
summary(cdata_host$data$pred_pcr)
summary(cdata_host$data$pred_comp)

# combine tree and data
dtree=treeio::full_join(as.treedata(cdata_host$phy),cdata_host$data,by="label")

# plot base tree
pbase=ggtree(dtree,layout="fan",branch.length="none",size=0.25)

# get tree data
tdata=pbase$data

# get tips only
tdata=tdata[which(tdata$isTip==T),]

# set x max
xmax=max(tdata$x)+10

# make dataframe
samp=data.frame(x=tdata$x,
                y=tdata$y,
                yend=tdata$y,
                xend_pcr=scales::rescale(cdata_host$data$pred_pcr,c(max(tdata$x),xmax)),
                xend_comp=scales::rescale(cdata_host$data$pred_comp,c(max(tdata$x),xmax)),
                xend_mean=scales::rescale(cdata_host$data$pred_mean,c(max(tdata$x),xmax)),
                pcr_rs0.8=(cdata_host$data$pcr_rs0.8),
                pcr_mss3=(cdata_host$data$pcr_mss3),
                comp_rs0.8=(cdata_host$data$comp_rs0.8),
                comp_mss3=(cdata_host$data$comp_mss3),
                factor_pcr_rs0.8=as.factor((cdata_host$data$pcr_rs0.8)),
                factor_pcr_mss3=as.factor((cdata_host$data$pcr_mss3)),
                factor_comp_rs0.8=as.factor((cdata_host$data$comp_rs0.8)),
                factor_comp_mss3=as.factor((cdata_host$data$comp_mss3)),
                treename=tdata$label)

# Separate df into predicted host genera and non-predicted host genera for different thresholds
samp_nopcr_rs0.8 <- samp[samp$pcr_rs0.8==0,]
samp_pcr_rs0.8 <- samp[samp$pcr_rs0.8>0,] #121
samp_nopcr_mss3 <- samp[samp$pcr_mss3==0,]
samp_pcr_mss3 <- samp[samp$pcr_mss3>0,] #n=136

samp_nocomp_rs0.8 <- samp[samp$comp_rs0.8==0,]
samp_comp_rs0.8 <- samp[samp$comp_rs0.8>0,] #100
samp_nocomp_mss3 <- samp[samp$comp_mss3==0,]
samp_comp_mss3 <- samp[samp$comp_mss3>0,] #191

# Plot base tree and highlight significant clades for PCR model
gg=pbase
for(i in 1:nrow(pcrpred_pf_results)){
  gg=gg+
    geom_hilight(node=pcrpred_pf_results$node[i],
                 alpha=ifelse(pcrpred_pf_results$tips[i]/Ntip(cdata_host$phy)<0.5,0.5,0.25), 
                 fill="black")
}

# Add PCR pred-probs and assign color based on binary classification assuming rs0.8
p1=gg+
  geom_segment(
    data=samp_nopcr_rs0.8,
    mapping=aes(x=x,y=y,xend=xend_pcr,yend=yend,
                alpha=factor_pcr_rs0.8),
    color="tomato2", linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(
    data=samp_pcr_rs0.8, 
    mapping=aes(x=x,y=y,xend=xend_pcr,yend=yend,
                colour=factor(factor_pcr_rs0.8)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1,
                      guide=guide_legend(reverse=TRUE),
                      name="Evidence type")

# Add PCR pred-probs and assign color based on binary classification assuming mss3
p2=gg+
  geom_segment(
    data=samp_nopcr_mss3,
    mapping=aes(x=x,y=y,xend=xend_pcr,yend=yend,
                alpha=factor_pcr_mss3),
      color="tomato2", linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(
    data=samp_pcr_mss3, 
    mapping=aes(x=x,y=y,xend=xend_pcr,yend=yend,
                colour=factor(factor_pcr_mss3)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1,
                      guide=guide_legend(reverse=TRUE),
                      name="Evidence type")

# Competence
gg=pbase
for(i in 1:nrow(comppred_pf_results)){
  gg=gg+
    geom_hilight(node=comppred_pf_results$node[i],
                 alpha=ifelse(comppred_pf_results$tips[i]/Ntip(cdata_host$phy)<0.5,0.5,0.25),
                 fill="black")
}

# Add preds to comp results based on rs0.8
p3=gg+
  geom_segment(
    data=samp_nocomp_rs0.8,
    mapping=aes(x=x,y=y,xend=xend_comp,yend=yend,
                alpha=factor_comp_rs0.8),
    color="tomato2", linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(
    data=samp_comp_rs0.8,
    mapping=aes(x=x,y=y,xend=xend_comp,yend=yend,
                colour=factor(factor_comp_rs0.8)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1,
                      guide=guide_legend(reverse=TRUE),
                      name="Evidence type")

# Add preds to comp results based on mss3
p4=gg+
  geom_segment(
    data=samp_nocomp_mss3,
    mapping=aes(x=x,y=y,xend=xend_comp,yend=yend,
                alpha=factor_comp_mss3),
    color="tomato2", linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(
    data=samp_comp_mss3,
    mapping=aes(x=x,y=y,xend=xend_comp,yend=yend,
                colour=factor(factor_comp_mss3)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1,
                      guide=guide_legend(reverse=TRUE),
                      name="Evidence type")

# arrange pcr trees in single plot
tree_pcr=ggarrange(p1,p2,
              labels=c("(A) PCR ReqSens0.8","(B) PCR MaxSensSpec"),
              font.label=list(face="plain",size=13),
              ncol=2,nrow=1,
              common.legend = TRUE, legend="left")

# save as figure 2
png("figures/fig2_tree_pcr.png",width=12,height=6,units="in",res=600)
tree_pcr
dev.off()

# arrange comp trees in single plot
tree_comp=ggarrange(p3,p4,
              labels=c("(A) Comp ReqSens0.8", "(B) Comp MaxSensSpec"),
              font.label=list(face="plain",size=13),
              ncol=2,nrow=1,
              common.legend = TRUE, legend="left")

# save as supp figure 1
png("figures/supplementary/s1fig_tree_comp.png",width=12,height=6,units="in",res=600)
tree_comp
dev.off()

### Link Prediction Model 1 (includes VACV links and trained on host and viral traits) ###

# Summarize distribution of predicted probabilities 
summary(cdata_link$data$pred_Model1)

# Cap outliers at 0.15, 0.1, and 95% percentile
cdata_link$data$cap0.15_pred_Model1 = ifelse(cdata_link$data$pred_Model1 > 0.15, 0.15, cdata_link$data$pred_Model1)
cdata_link$data$cap0.1_pred_Model1 = ifelse(cdata_link$data$pred_Model1 > 0.1, 0.1, cdata_link$data$pred_Model1)
cdata_link$data$quant0.95_pred_Model1 = ifelse(cdata_link$data$pred_Model1 > quantile(cdata_link$data$pred_Model1,0.95), quantile(cdata_link$data$pred_Model1,0.95),cdata_link$data$pred_Model1)

# Make data frame for Model 1
samp=data.frame(x=tdata$x,
                y=tdata$y,
                yend=tdata$y,
                # xend_Model1=rescale(cdata_link$data$pred_Model1,c(max(tdata$x),xmax)),
                xend_Model1=rescale(cdata_link$data$cap0.15_pred_Model1,c(max(tdata$x),xmax)), #rescale(x, newrange) where x is numeric object and newrange is the new min and max
                # xend_Model1=rescale(cdata_link$data$quant0.95_pred_Model1,c(max(tdata$x),xmax)),
                # xend_Model1_circle=rescale(cdata_link$data$circle0.1,c(max(tdata$x),xmax)),
                link1_rs0.8=cdata_link$data$link1_rs0.8,
                link1_rs0.85=cdata_link$data$link1_rs0.85,
                link1_rs0.9=cdata_link$data$link1_rs0.9,
                link1_mss3=cdata_link$data$link1_mss3,
                factor_link1_rs0.8=as.factor((cdata_link$data$link1_rs0.8)),
                factor_link1_rs0.85=as.factor((cdata_link$data$link1_rs0.85)),
                factor_link1_rs0.9=as.factor((cdata_link$data$link1_rs0.9)),
                factor_link1_mss3=as.factor((cdata_link$data$link1_mss3)),
                treename=tdata$label)

# For plotting, separate df into predicted host genera and non-predicted host genera for different thresholds
samp_nopred_rs0.8 <- samp[samp$link1_rs0.8==0,]
samp_pred_rs0.8 <- samp[samp$link1_rs0.8>0,]
samp_nopred_rs0.85 <- samp[samp$link1_rs0.85==0,]
samp_pred_rs0.85 <- samp[samp$link1_rs0.85>0,]
samp_nopred_rs0.9 <- samp[samp$link1_rs0.9==0,]
samp_pred_rs0.9 <- samp[samp$link1_rs0.9>0,]
samp_nopred_mss3 <- samp[samp$link1_mss3==0,]
samp_pred_mss3 <- samp[samp$link1_mss3>0,]

# Plot circular tree base and the significant clades identified by phylofactorization on Model 1 results
gg=pbase
for(i in 1:nrow(Model1pred_pf_results)){
  gg=gg+
    geom_hilight(node=Model1pred_pf_results$node[i],
                 alpha=ifelse(Model1pred_pf_results$tips[i]/Ntip(cdata_link$phy)<0.5,0.5,0.25), #alpha=0.5 is less transparent opacity); 0.25 is more transparent opacity
                 fill="black")
}

# Add predicted probabilities as bars colored based on whether host genera had any predicted links (binary)
p1_rs0.8=gg+
  geom_segment(
    data=samp_nopred_rs0.8,
    mapping=aes(x=x,y=y,xend=xend_Model1,yend=yend,
                alpha=factor_link1_rs0.8),
    color="tomato2",linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(
    data=samp_pred_rs0.8,
    mapping=aes(x=x,y=y,xend=xend_Model1,yend=yend,
                colour=factor(link1_rs0.8)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1,
                      guide=guide_legend(reverse=TRUE),
                      limits=seq(from=1,to=12),
                      name="Number of predicted links\nwith OPV species") +
 theme(legend.position=c(1.1,.5))

p1_rs0.85=gg+
  geom_segment(
    data=samp_nopred_rs0.85,
    mapping=aes(x=x,y=y,xend=xend_Model1,yend=yend,
                alpha=factor_link1_rs0.85),
    color="tomato2",linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(data=samp_pred_rs0.85,aes(x=x,y=y,xend=xend_Model1,yend=yend,
                                  colour=factor(link1_rs0.85)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1, 
                      guide=guide_legend(reverse=TRUE), 
                      limits=seq(from=1,to=12),
                      name="Number of predicted links\nwith OPV species") +
 theme(legend.position=c(1.1,.5))

p1_rs0.9=gg+
  geom_segment(
    data=samp_nopred_rs0.9,
    mapping=aes(x=x,y=y,xend=xend_Model1,yend=yend,
                alpha=factor_link1_rs0.9),
    color="tomato2",linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(data=samp_pred_rs0.9,aes(x=x,y=y,xend=xend_Model1,yend=yend,
                                  colour=factor(link1_rs0.9)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1, 
                      guide=guide_legend(reverse=TRUE), 
                      limits=seq(from=1,to=12),
                      name="Number of predicted links\nwith OPV species") +
 theme(legend.position=c(1.1,.5))

p1_mss3=gg+
  geom_segment(
    data=samp_nopred_mss3,
    mapping=aes(x=x,y=y,xend=xend_Model1,yend=yend,
                alpha=factor_link1_mss3),
    color="tomato2",linewidth=0.75)+
  scale_alpha_discrete(range=c(1,1),name="No predicted links")+
  geom_segment(data=samp_pred_mss3,aes(x=x,y=y,xend=xend_Model1,yend=yend,
                                  colour=factor(link1_mss3)),linewidth=0.75,)+
  scale_color_viridis(discrete=TRUE,option="D", direction=-1, 
                      guide=guide_legend(reverse=TRUE),
                      limits=seq(from=1,to=12),
                      name="Number of predicted links\nwith OPV species") +
 theme(legend.position=c(1.1,.5))

# Combine figures for different threshold values
tree_model1=ggarrange(p1_rs0.8,p1_rs0.85, p1_rs0.9,p1_mss3,
              labels=c("(a) ReqSens0.8; Th=0.14","(b) ReqSens0.85; Th=0.08","(c) ReqSens0.9; Th=0.05","(d) MaxSensSpec; Th=0.06"),
              label.x=c(-0.25,-0.25,-0.25,-0.25),
              label.y=0.2,
              font.label=list(face="plain",size=13),
              ncol=2,nrow=2,
              common.legend = TRUE, legend="right")

# Visualize and select threshold to apply binary classification
tree_model1

# Let's use ReqSens0.8 and MaxSensSpec to demonstrate the impact of threshold moving on binary classification
tree_model1=ggarrange(p1_rs0.8,p1_mss3,
              labels=c("(C) ReqSens0.8","(D) MaxSensSpec"),
              label.x=c(0.27,0.27),
              label.y=c(1,1),
              font.label=list(face="plain",size=13),
              ncol=1,nrow=2,
              common.legend = TRUE, legend="left")

# Save tree plot
png("figures/fig2_tree_model1.png",width=12,height=8,units="in",res=600)
tree_model1
dev.off()

# # Export tip labels of mammal orders for Steph
# tiplabels <- ggtree(dtree,layout="fan",branch.length="none",size=0.25) + geom_tiplab(aes(label = dtree@extraInfo$ord))
# png("Output/tiplabels_forSteph(1).png",width=24,height=24,units="in", res=300)
# tiplabels
# dev.off()
# 
# # Export tip labels again for mammal orders for Steph but dropping duplicate labels
# temp_tree <- dtree
# temp_tree@extraInfo$ord[duplicated(temp_tree@extraInfo$ord)] <- NA 
# 
# tiplabels <- ggtree(dtree,layout="fan",branch.length="none",size=0.25) + geom_tiplab(aes(label = temp_tree@extraInfo$ord))
# png("Output/tiplabels_forSteph(2).png",width=24,height=24,units="in", res=300)
# tiplabels
# dev.off()

### INTERMISSION: TRYING TO ADD SCALE/CONCENTRIC CIRCLES ########

# Install package ggtreeExtra
#https://github.com/YuLab-SMU/plotting-tree-with-data-using-ggtreeExtra
BiocManager::install("ggtreeExtra")
library(ggrteeExtra)

# Add concentric circles
#https://yulab-smu.top/treedata-book/chapter10.html
BiocManager::install("phyloseq")
data("GlobalPatterns")

plot <- p1_rs0.8 + 
  geom_segment(data=samp,aes(x=x,y=y,xend=xend_Model1_circle,yend=yend,
                                  colour=factor(link1_rs0.8)),linewidth=0.75,)
gg +
     geom_fruit(
         data=samp,
         geom=geom_segment,
         mapping = aes(
                     y=0.5,
                     x=x,
                     xend=xend_Model1,
                     yend=yend,
                     colour=factor(samp$link1_rs0.8)),
         # axis.params=list(
         #                 axis       = "x",
         #                 text.size  = 1.8,
         #                 hjust      = 1,
         #                 vjust      = 0.5,
         #                 nbreak     = 3,
         #             ),
         grid.params=list()
     ) 

# Sample silhouette image code for the outermost ring
install.packages("ggtreeExtra")
library(ggtreeExtra)
library(ggimage)
phylopicda <- read.csv("https://raw.githubusercontent.com/YuLab-SMU/plotting-tree-with-data-using-ggtreeExtra/master/data/VertebrateGutMicrobiomes/data_phylopic_uid.csv")

p1_rs0.8+geom_nodelab(aes(image=phylopicda), geom="phylopic", alpha=.5, color='steelblue')

fig4 <- fig3 +
      new_scale_colour() +
      geom_fruit(
          data=phylopicda,
          geom=geom_phylopic,
          mapping=aes(y=taxa, image=uid, color=class),
          size=0.035,
          offset=0.16,
          alpha=0.8,
          position=position_identityx()
      ) +
      scale_colour_manual(
          values=c("#b2df8a","#33a02c","#fb9a99",
                   "#EACB47","#6a3d9a"),
          guide="none"
      ) +
      theme(
          legend.background=element_rect(fill=NA),
          legend.title=element_text(size=7),
          legend.text=element_text(size=5),
          legend.spacing.y = unit(0.02, "cm")
      )  

# Annotate tree with Phylopic (deprecated?): https://yulab-smu.top/treedata-book/chapter8.html

### END INTERMISSION ###

```


3. Mapping Host Distribution
============================

### *Load required packages and set system*

```{r map_load}

# Libraries for generating maps
library(classInt)
library(tidyverse)
library(raster)
library(rgdal)  # switches to sf in 2023
library(dismo)
library(XML)
library(maps)
library(sp)
library(dplyr)
library(devtools)
#install_github("hunzikp/velox")
library(velox)
library(fasterize)
library(sf)
library(openxlsx)
library(readxl)
library(PresenceAbsence) #for thresholding results

# Set working directory
setwd("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost")

```

### *Explore threshold moving on the mapping of host distribution for link prediction model 1*
Figures: *map_model1_kn_unrs0.8_unrs0.85_unmss.png*, 
         *map_model1_kn_unrs0.8_unrs0.9_unmss.png*,
         *map_model1_kn_unrs0.9.png*

```{r map_threshold}

## Before proceeding, make sure you have downloaded "MAMMALS.shp" to your working directory. This shape file of mammal geographic range can be obtained from IUCN Red List Spatial Database: <https://www.iucnredlist.org/resources/spatial-data-download>. This file (>1GB) is only required for this section of the code ("3. Mapping host distribution").

# Load shape file of mammal geographic range
iucn <- sf::st_read(dsn ="/Users/katietseng/Desktop/PoxHost(copy)/data/raw/MAMMALS/MAMMALS.shp", layer='MAMMALS')

# Make a blank raster
r <- disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)

# Create four layers
iucn$treename=sapply(strsplit(iucn$binomial,' '),function(x) paste(x[1],sep=' '))

# Pull out the relevant lists of known hosts and predicted hosts for all OPVs
pred1 %>% filter(link1==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known.1 #n=102
pred1 %>% filter(bin_rs0.8==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.8 #n=503
pred1 %>% filter(bin_rs0.85==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.85 #n=503
pred1 %>% filter(bin_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.9 #n=2266
pred1 %>% filter(bin_mss3==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_mss3 #n=1399

# Pull out the relevant lists of predicted unknown hosts for all OPVs
pred.1_unk_rs0.8 <- pred.1_rs0.8[!(pred.1_rs0.8 %in% known.1)] #n=311
pred.1_unk_rs0.85 <- pred.1_rs0.85[!(pred.1_rs0.85 %in% known.1)] #n=311
pred.1_unk_rs0.9 <- pred.1_rs0.9[!(pred.1_rs0.9 %in% known.1)] #n=1844
pred.1_unk_mss3 <- pred.1_mss3[!(pred.1_mss3 %in% known.1)] #n=1097

###iucn$treename is the genus of the iucn species
iucn.1_kn <- iucn[iucn$treename %in% known.1,] #n=1699
iucn.2_rs0.8 <- iucn[iucn$treename %in% pred.1_unk_rs0.8,] #n=1586
iucn.3_rs0.85 <- iucn[iucn$treename %in% pred.1_unk_rs0.85,] #n=1586
iucn.3_rs0.9 <- iucn[iucn$treename %in% pred.1_unk_rs0.9,] #n=5155 
iucn.4_mss3 <- iucn[iucn$treename %in% pred.1_unk_mss3,] #n=4838

library(fasterize)
map.kn1 <- (fasterize(iucn.1_kn, r, fun="sum"))
map.pr1_rs0.8 <- (fasterize(iucn.2_rs0.8, r, fun="sum"))
map.pr1_rs0.85 <- (fasterize(iucn.3_rs0.85, r, fun="sum"))
map.pr1_rs0.9 <- (fasterize(iucn.3_rs0.9, r, fun="sum"))
map.pr1_mss3 <- (fasterize(iucn.4_mss3, r, fun="sum"))

# Add zeros for the continental area 
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}

map.kn1 <- fix(map.kn1)
map.pr1_rs0.8 <- fix(map.pr1_rs0.8)
map.pr1_rs0.85 <- fix(map.pr1_rs0.85)
map.pr1_rs0.9 <- fix(map.pr1_rs0.9)
map.pr1_mss3 <- fix(map.pr1_mss3)

#Maps 1 includes req.sens 85%
raster::stack(map.kn1, map.pr1_rs0.8, map.pr1_rs0.85, map.pr1_mss3) %>% raster::trim() -> maps1 #alternatively, can use tera package

#Maps 2 includes req.sens 90%
raster::stack(map.kn1, map.pr1_rs0.8, map.pr1_rs0.9, map.pr1_mss3) %>% raster::trim() -> maps2 #alternatively, can use tera package

names(maps1) <- c('KnownModel1', 'PredModel1_ReqSens0.8', 'PredModel1_ReqSens0.85', 'PredModel1_MaxSensSpec')
names(maps2) <- c('KnownModel1', 'PredModel1_Unk_ReqSens0.8', 'PredModel1_Unk_ReqSens0.9', 'PredModel1_Unk_MaxSensSpec')

# Generate the actual visualization
library(rasterVis)
library(RColorBrewer)

mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"

png("figures/other/linkpred/map_model1_kn_unrs0.8_unrs0.85_unmss.png",width=10,height=10,units="in",res=300)
rasterVis::levelplot(maps1,  
                     col.regions = mycolors,
                     #at = seq(0, 15, 1),
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     #labels = labels,
                     maxpixels = 5e6)
dev.off()

png("figures/other/linkpred/map_model1_kn_unrs0.8_unrs0.9_unmss.png",width=10,height=10,units="in",res=300)
rasterVis::levelplot(maps2,  
                     col.regions = mycolors,
                     #at = seq(0, 15, 1),
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     #labels = labels,
                     maxpixels = 5e6)
dev.off()

### Selected map using 90% sensitivity threshold

# Final selected map using rs0.9
raster::stack(map.kn1, map.pr1_rs0.9) %>% raster::trim() -> maps_rs0.9
names(maps_rs0.9) <- c('KnownModel1', 'PredModel1_Unk_ReqSens0.9')

# Generate the actual visualization
png("figures/other/linkpred/map_model1_kn_unrs0.9.png",width=10,height=10,units="in",res=300)
rasterVis::levelplot(maps_rs0.9,  
                     col.regions = mycolors,
                     #at = seq(0, 15, 1),
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     #labels = labels,
                     maxpixels = 5e6)
dev.off()

```

### *Generate maps of host distribution for manuscript and supplementary info*
Figures: 

```{r map_manuscript}

#Threshold the results
library(PresenceAbsence)

set.seed(12345)

#################################################################
#### Supplementary Info: Map of host trait model predictions ####
#################################################################

# load file
pred <- read.csv("figures/other/hosttrait/table_predprobs_hosttrait.csv")

# optimal thresholds for PCR
t.pcr <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
                            threshold = 10001,
                            opt.methods = 10,
                            req.sens = 0.90,
                            na.rm = TRUE)

# optimal threshold for competence
t.comp <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
                             threshold = 10001,
                             opt.methods = 10,
                             req.sens = 0.90,
                             na.rm = TRUE)

# threshold the results to binary outputs
pred %>%
  mutate(bin_comp = (pred_comp > t.comp$pred_comp),
         bin_pcr = (pred_pcr > t.pcr$pred_pcr)) -> pred

# get the relevant lists of known and predicted hosts for all OPVs keeping pcr and competence predictions separate 
pred %>% filter(PCR==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known_pcr
pred %>% filter(competence==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known_comp
pred %>% filter(bin_pcr==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_pcr
pred %>% filter(bin_comp==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred_comp

# pull out the relevant lists of predicted unknown hosts for all OPVs keeping pcr and competence predictions separate
unk_pcr <- pred_pcr[!(pred_pcr %in% known_pcr)] #n=197
unk_comp <- pred_comp[!(pred_comp %in% known_comp)] #n=118

# get the relevant lists of known and predicted hosts for all OPVs combining comp and pcr predictions for manuscript
pred %>% filter(competence==1|PCR==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known #71
pred %>% filter(bin_comp==1|bin_pcr==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.pcrcomp #n=299
sort(pred.pcrcomp[!(pred.pcrcomp %in% known)]) -> unknown #235

#### Create Map ####

# load shape file of mammal geographic range
iucn <- sf::st_read(dsn = "/Users/katietseng/Desktop/PoxHost(copy)/data/raw/MAMMALS/MAMMALS.shp", layer='MAMMALS')

# make a blank raster (must be connected to wifi for the disaggregate function)
r <- raster::disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)

# create two layers
iucn$treename=sapply(strsplit(iucn$binomial,' '),function(x) paste(x[1],sep=' '))

iucn_known <- iucn[iucn$treename %in% known,]
iucn_pred <- iucn[iucn$treename %in% pred.pcrcomp,]

map_known <- (fasterize(iucn_known, r, fun="sum"))
map_pred <- (fasterize(iucn_pred, r, fun="sum"))

# add zeros for the continental area 
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}

map_known <- fix(map_known)
map_pred <- fix(map_pred)

raster::stack(map_known, map_pred) %>% raster::trim() -> maps_host #alternatively, can use tera package

names(maps_host) <- c('Host trait model - known', 'Host trait model - pred0.9')

# generate the actual visualization
library(rasterVis)
library(RColorBrewer)

mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"

map_host_rs0.9_supplementary <- rasterVis::levelplot(maps_host,  
                     col.regions = mycolors,
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     labels = labels,
                     maxpixels = 5e6)

png("figures/other/hosttrait/map_hosttrait_rs0.9.png",width=6,height=8,units="in",res=600)
map_host_rs0.9_supplementary
dev.off()

pdf("figures/other/hosttrait/map_hosttrait_rs0.9.pdf",width=6,height=8)
map_host_rs0.9_supplementary
dev.off()

###############################################################
#### Main Text - Figure 5: Map of link prediction model 1 predictions ####
###############################################################

# load link prediction file
pred1 <- read_excel("figures/other/linkpred/table_predprobs_link.xlsx", sheet = "model1")
pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)

# add method applying 90% required sensitivity
ts1_rs0.9 <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.9,
                           na.rm = TRUE)

pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)
  
# threshold the results to binary outputs
pred1 %>%
  mutate(bin_rs0.9 = ifelse(pred_Model1 > ts1_rs0.9$pred_Model1, 1, 0)) -> pred1
  
# pull out the relevant lists of known hosts and predicted hosts for all OPVs
pred1 %>% filter(link1==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known.1 #n=101
pred1 %>% filter(bin_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.9 #n=1791

# pull out the relevant lists of predicted unknown hosts for all OPVs
pred.1_unk_rs0.9 <- pred.1_rs0.9[!(pred.1_rs0.9 %in% known.1)] #n=1436

#### Create Map ####

# load shape file of mammal geographic range
iucn <- sf::st_read(dsn = "/Users/katietseng/Desktop/PoxHost(copy)/data/raw/MAMMALS/MAMMALS.shp", layer='MAMMALS')

# make a blank raster (must be connected to wifi for the disaggregate function)
r <- raster::disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)

# create two layers
iucn$treename=sapply(strsplit(iucn$binomial,' '),function(x) paste(x[1],sep=' '))

iucn_known <- iucn[iucn$treename %in% known.1,] #n=1699
iucn_link <- iucn[iucn$treename %in% pred.1_rs0.9,] #n=6811

map_known <- (fasterize(iucn_known, r, fun="sum"))
map_link <- (fasterize(iucn_link, r, fun="sum"))

# add zeros for the continental area 
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}

map_known <- fix(map_known)
map_link <- fix(map_link)

raster::stack(map_known, map_link) %>% raster::trim() -> maps_link #alternatively, can use tera package

names(maps_link) <- c('Link prediction model - known', 'Link prediction model - pred0.9')

# generate the actual visualization
library(rasterVis)
library(RColorBrewer)

mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"

map_link_rs0.9 <- rasterVis::levelplot(maps_link,  
                     col.regions = mycolors,
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     labels = labels,
                     maxpixels = 5e6)

png("Output/fig5ab_map_link_rs0.9.png",width=6,height=8,units="in",res=600)
map_link_rs0.9
dev.off()

pdf("figures/fig5ab_map_link_rs0.9.pdf",width=6,height=8)
map_link_rs0.9
dev.off()

#############################################
##### Main Text: OPV Susceptibility Map #####
#############################################

fig1sf <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/mpx_landscape/data/world-estimates-vaxxed-sf.RDS")
fig1sf$perc_unvaxxed <- 100-fig1sf$perc_vaxxed

r <- raster::disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)
map_vaccinated <- (fasterize(fig1sf, r, field = "perc_vaxxed", fun="max"))
map_susceptible <- (fasterize(fig1sf, r, field = "perc_unvaxxed", fun="max"))
 
# fig1sf_us <- subset(fig1sf, COUNTRYNM == "united states of america")
# head(fig1sf_us)
fig1sf_au <- subset(fig1sf, COUNTRYNM == "australia")

# Add zeros for the continental area
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}

# map_vaccinated <- fix(map_vaccinated)
map_susceptible <- fix(map_susceptible)

# Generate the actual visualization
library(rasterVis)
library(RColorBrewer)

mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"

# #alternative palette
# library(MetBrewer)
# mycolors <- met.brewer("VanGogh3",50)

map_susceptible <- rasterVis::levelplot(map_susceptible,  
                     col.regions = mycolors,
                     margin=F, #no marginal graphs
                     ylim = c(-60,90), #extend yaxis
                     alpha = 0.5, 
                     scales=list(alternating=FALSE), #prevents axis labels from alternating from one side of group of panels to the other
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     maxpixels=5e6
                     )

png("Output/fig5c_map_susceptible.png",width=6,height=4,units="in",res=600)
map_susceptible
dev.off()

pdf("Output/fig5c_map_susceptible.pdf",width=6,height=4)
map_susceptible
dev.off()

# #####################################################################################
# ##### Main Text: Arranging link prediction and susceptiblity maps in one figure #####
# #####################################################################################
# 
# ### Link Prediction Map ###
# 
# # load link prediction file
# pred1 <- read_excel("Output/table_predprobs_linkprediction.xlsx", sheet = "model1")
# pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)
# 
# # add method applying 90% required sensitivity
# ts1_rs0.9 <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
#                            threshold = 10001,
#                            opt.methods = c(10), 
#                            req.sens = 0.9,
#                            na.rm = TRUE)
# 
# pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)
#   
# # threshold the results to binary outputs
# pred1 %>%
#   mutate(bin_rs0.9 = ifelse(pred_Model1 > ts1_rs0.9$pred_Model1, 1, 0)) -> pred1
#   
# # pull out the relevant lists of known hosts and predicted hosts for all OPVs
# pred1 %>% filter(link1==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known.1 #n=101
# pred1 %>% filter(bin_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.9 #n=1791
# 
# # pull out the relevant lists of predicted unknown hosts for all OPVs
# pred.1_unk_rs0.9 <- pred.1_rs0.9[!(pred.1_rs0.9 %in% known.1)] #n=1436
# 
# # Load shape file of mammal geographic range
# iucn <- sf::st_read(dsn = "/Users/katietseng/Desktop/PoxHost(copy)/data/raw/MAMMALS/MAMMALS.shp", layer='MAMMALS')
# 
# # Make a blank raster (must be connected to wifi for the disaggregate function)
# r <- raster::disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)
# 
# # Create two layers
# iucn$treename=sapply(strsplit(iucn$binomial,' '),function(x) paste(x[1],sep=' '))
# 
# iucn_known <- iucn[iucn$treename %in% known.1,] #n=1676
# iucn_link <- iucn[iucn$treename %in% pred.1_rs0.9,] #n=1699
# 
# map_known <- (fasterize(iucn_known, r, fun="sum"))
# map_link <- (fasterize(iucn_link, r, fun="sum"))
# 
# # Add zeros for the continental area 
# fix <- function(x) {sum(x,r,na.rm=TRUE)+r}
# 
# map_known <- fix(map_known)
# map_link <- fix(map_link)
# 
# ### Human Susceptibility Map: https://github.com/bansallab/mpx_landscape ###
# 
# fig1sf <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/mpx_landscape/data/world-estimates-vaxxed-sf.RDS")
# 
# # Generate variable of unvaxxed (susceptible) from perc_vaxxed
# fig1sf$perc_unvaxxed <- 100-fig1sf$perc_vaxxed
# 
# # Create additional layer
# #map_vaccinated <- (fasterize(fig1sf, r, field = "perc_vaxxed", fun="max"))
# map_susceptible <- (fasterize(fig1sf, r, field = "perc_unvaxxed", fun="max"))
#  
# # Add zeros for the continental area
# map_susceptible <- fix(map_susceptible)
# 
# ### Combine Link Prediction and Susceptibility Maps ###
# 
# raster::stack(map_known, map_link, map_susceptible) %>% raster::trim() -> maps #alternatively, can use tera package
# names(maps) <- c('Link prediction model - observed', 'Link prediction model - predicted0.9', 'Human susceptibility')
# 
# # create color palette for maps
# library(rasterVis)
# library(RColorBrewer)
# 
# mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
# mycolors[1] <- "#C0C0C0"
#   
# # Generate the actual visualizations
# maps_combined <- rasterVis::levelplot(maps,  
#                      col.regions = mycolors,
#                      alpha = 0.5, 
#                      scales=list(alternating=FALSE), #prevents axis labels from alternating from one side of group of panels to the other
#                      par.strip.text=list(cex=0),
#                      xlab = NULL, ylab = NULL,
#                      labels = labels,
#                      maxpixels = 5e6)
# 
# png("figures/fig4_maps_combined.png",width=8,height=12,units="in",res=600)
# maps_combined
# dev.off()

#############################################################
#### Supplemental Figure: Map of Mpox link prediction model predictions with susceptibility ####
#############################################################

# load link prediction file
pred1 <- read_excel("Output/table_predprobs_linkprediction.xlsx", sheet = "model1")
pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)

# keep mpox predictions only
unique(pred1$virus)
pred1 <- pred1[pred1$virus=="monkeypox virus",]

# add method applying 90% required sensitivity
ts1_rs0.9 <- optimal.thresholds(data.frame(pred1[,c('virus_treename','link1','pred_Model1')]),
                           threshold = 10001,
                           opt.methods = c(10), 
                           req.sens = 0.9,
                           na.rm = TRUE)

pred1$virus_treename=paste0(pred1$virus, "%",pred1$treename)
  
# threshold the results to binary outputs
pred1 %>%
  mutate(bin_rs0.9 = ifelse(pred_Model1 > ts1_rs0.9$pred_Model1, 1, 0)) -> pred1
  
# pull out the relevant lists of known hosts and predicted hosts
pred1 %>% filter(link1==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> known.1 #n=19
pred1 %>% filter(bin_rs0.9==1) %>% dplyr::pull(treename) %>% gsub("_"," ",.) -> pred.1_rs0.9 #n=49

# pull out the relevant lists of predicted unknown hosts for all OPVs
pred.1_unk_rs0.9 <- pred.1_rs0.9[!(pred.1_rs0.9 %in% known.1)] #n=31

#### Create Map ####

# Load shape file of mammal geographic range
iucn <- sf::st_read(dsn = "/Users/katietseng/Desktop/PoxHost(copy)/data/raw/MAMMALS/MAMMALS.shp", layer='MAMMALS')

# Make a blank raster (must be connected to wifi for the disaggregate function)
r <- raster::disaggregate(getData("worldclim",var="alt",res=2.5)*0,2)

# Create two layers
iucn$treename=sapply(strsplit(iucn$binomial,' '),function(x) paste(x[1],sep=' '))

iucn_known <- iucn[iucn$treename %in% known.1,] #n=1676
iucn_link <- iucn[iucn$treename %in% pred.1_rs0.9,] #n=1699

map_known <- (fasterize(iucn_known, r, fun="sum"))
map_link <- (fasterize(iucn_link, r, fun="sum"))

# Add zeros for the continental area 
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}

map_known <- fix(map_known)
map_link <- fix(map_link)

raster::stack(map_known, map_link) %>% raster::trim() -> maps #alternatively, can use tera package
names(maps) <- c('Link prediction model - observed', 'Link prediction model - predicted0.9')

# create color palette for maps
library(rasterVis)
library(RColorBrewer)

mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"

# Generate the actual visualizations
map_mpxv <- rasterVis::levelplot(maps,  
                     col.regions = mycolors,
                     alpha = 0.5, 
                     scales=list(alternating=FALSE),
                     par.strip.text=list(cex=0),
                     xlab = NULL, ylab = NULL,
                     labels = labels,
                     maxpixels = 5e6)

png("figures/supplementary/s8fig_map_mpxv.png",width=6,height=8,units="in",res=600)
map_mpxv
dev.off()

pdf("figures/supplementary/s8fig_map_mpxv.pdf",width=6,height=8)
map_mpxv
dev.off()

```


4. Feature Importance
=====================

In this chapter, we examine predictions from our BRT model identifying and ranking the importance of model features.

### *Load required packages and set system*

```{r feat_load}

# Libraries for BRT figures
library(tidyr)
library(ggplot2)
library(fastDummies)
library(caper)
library(phylofactor)
library(plotrix) #std.error
library(rstatix) 
library(ggrepel)
library(ggpubr) #ggarrange
library(dplyr)
library(openxlsx)

# Clean environment
rm(list=ls()) 
graphics.off()

# Set working directory
setwd("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost")

```

### *Identify and rank relative feature importance*
We compare and contrast the relative feature importance of the predictors in our models, determining the mean, variance, and standard error for each model. We then rank features by their relative importance, focusing on the top 10 predictive features. 
Figures: *boxplot_trait_ranking.png*
Tables: *table_ranks_model1*, *table_ranks_model2*

```{r feat_rank}

# Load data
pcr_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/pcr_brts.rds")

comp_brts <- readRDS("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_HostTraitModel/comp_brts.rds")

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model1/brts_Model1.RData")
brts1=brts
rm(brts, pm_brts) 

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model2/brts_Model2.RData")
brts2=brts 
rm(brts, pm_brts) 

load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost_HPC_30Jan2024/Kamiak_Results_Model3/brts_Model3.RData")
brts3=brts 
rm(brts, pm_brts) 

# Index non-missing
pcr_keep=which(!is.na(sapply(pcr_brts,function(x) x$testAUC)))
comp_keep=which(!is.na(sapply(comp_brts,function(x) x$testAUC)))
keep1=which(!is.na(sapply(brts1,function(x) x$testAUC)))
keep2=which(!is.na(sapply(brts2,function(x) x$testAUC)))
keep3=which(!is.na(sapply(brts3,function(x) x$testAUC)))

# Trim, keeping only those that are non-missing
pcr_brts=pcr_brts[pcr_keep]
comp_brts=comp_brts[comp_keep]
brts1=brts1[keep1]
brts2=brts2[keep2]
brts3=brts3[keep3]

# What was the relative importance/influence of each feature? Get values.
vinf=lapply(pcr_brts,function(x) x$rinf)
pcr_vinf=do.call(rbind,vinf)

# vinf=lapply(pcr_brts,function(x) x$rinf)
# vinf=lapply(vinf, function(x) {x <- x[order(x$var),]; x})
# b <- c()
# for (i in 1:length(vinf[[1]]$rel.inf)) {
#     a <- mean(sapply(vinf,function(x) x$rel.inf[i]))
#     b <- c(b,a)
# }

vinf=lapply(comp_brts,function(x) x$rinf)
comp_vinf=do.call(rbind,vinf)

vinf=lapply(brts1,function(x) x$rinf)
vinf1=do.call(rbind,vinf)

vinf=lapply(brts2,function(x) x$rinf)
vinf2=do.call(rbind,vinf)

vinf=lapply(brts3,function(x) x$rinf)
vinf3=do.call(rbind,vinf)

# What was the mean, standard error, and variance of feature relative influence?
vdata_pcr=data.frame(aggregate(rel.inf~var,data=pcr_vinf,mean),
                     aggregate(rel.inf~var,data=pcr_vinf,std.error)["rel.inf"],
                     aggregate(rel.inf~var,data=pcr_vinf,var)["rel.inf"])
  names(vdata_pcr)=c("var","rel.inf","rse","rvar")
  vdata_pcr=vdata_pcr[order(vdata_pcr$rel.inf,decreasing=T),]

vdata_comp=data.frame(aggregate(rel.inf~var,data=comp_vinf,mean),
                      aggregate(rel.inf~var,data=comp_vinf,std.error)["rel.inf"],
                      aggregate(rel.inf~var,data=comp_vinf,var)["rel.inf"])
  names(vdata_comp)=c("var","rel.inf","rse","rvar")
  vdata_comp=vdata_comp[order(vdata_comp$rel.inf,decreasing=T),]

vdata1=data.frame(aggregate(rel.inf~var,data=vinf1,mean),
                 aggregate(rel.inf~var,data=vinf1,std.error)["rel.inf"],
                 aggregate(rel.inf~var,data=vinf1,var)["rel.inf"])
  names(vdata1)=c("var","rel.inf","rse","rvar")
  vdata1=vdata1[order(vdata1$rel.inf,decreasing=T),]

vdata2=data.frame(aggregate(rel.inf~var,data=vinf2,mean),
                      aggregate(rel.inf~var,data=vinf2,std.error)["rel.inf"],
                      aggregate(rel.inf~var,data=vinf2,var)["rel.inf"])

  names(vdata2)=c("var","rel.inf","rse","rvar")
  vdata2=vdata2[order(vdata2$rel.inf,decreasing=T),]

vdata3=data.frame(aggregate(rel.inf~var,data=vinf3,mean),
                      aggregate(rel.inf~var,data=vinf3,std.error)["rel.inf"],
                      aggregate(rel.inf~var,data=vinf3,var)["rel.inf"])
  names(vdata3)=c("var","rel.inf","rse","rvar")
  vdata3=vdata3[order(vdata3$rel.inf,decreasing=T),]

# How does the average variance compare between models?
paste0("mean Relative Importance for Host exposure model: ", mean(vdata_pcr$rvar))
paste0("mean Relative Importance for Susceptible host model: ", mean(vdata_comp$rvar))
paste0("mean Relative Importance for Model 1: ", mean(vdata1$rvar))
paste0("mean Relative Importance for Model 2: ", mean(vdata2$rvar))
paste0("mean Relative Importance for Model 3: ", mean(vdata3$rvar))

# How does the variance of relative influence compare between models?
var(vdata_pcr$rel.inf)
var(vdata_comp$rel.inf)
paste0("variance in mean Relative Importance for Model 1: ", var(vdata1$rel.inf))
paste0("variance in mean Relative Importance for Model 2: ", var(vdata2$rel.inf))
paste0("variance in mean Relative Importance for Model 3: ", var(vdata3$rel.inf))

# Can we rank features by their relative influence?
vdata_pcr$pcr_rank=1:nrow(vdata_pcr)
vdata_comp$comp_rank=1:nrow(vdata_comp)
vdata1$rank1=1:nrow(vdata1)
vdata2$rank2=1:nrow(vdata2)
vdata3$rank3=1:nrow(vdata3)

# What is their relative influence/importance as a proportion?
vdata_pcr$pcr_imp=vdata_pcr$rel.inf/100
vdata_comp$comp_imp=vdata_comp$rel.inf/100
vdata1$imp1=vdata1$rel.inf/100
vdata2$imp2=vdata2$rel.inf/100
vdata3$imp3=vdata3$rel.inf/100

# # Combine the rankings
# ranks_hosttraits=merge(vdata_pcr[c("var","pcr_rank","pcr_imp")],
#                        vdata_comp[c("var","comp_rank","comp_imp")],
#                         by="var")
# 
# ranks_model12=merge(vdata1[c("var","rank1","imp1")],
#                            vdata2[c("var","rank2","imp2")],
#                            by="var")

# Create a table of ranked features and their relative importance for Model 1
ranks_pcr=vdata_pcr[c("var","pcr_imp","pcr_rank")]
names(ranks_pcr)[names(ranks_pcr) == "var"] <- "feature"
ranks_pcr=ranks_pcr[order(ranks_pcr$pcr_rank),]

ranks_comp=vdata_comp[c("var","comp_imp","comp_rank")]
names(ranks_comp)[names(ranks_comp) == "var"] <- "feature"
ranks_comp=ranks_comp[order(ranks_comp$comp_rank),]

ranks_model1=vdata1[c("var","imp1","rank1")]
names(ranks_model1)[names(ranks_model1) == "var"] <- "feature"
ranks_model1=ranks_model1[order(ranks_model1$rank1),]

ranks_model2=vdata2[c("var","imp2","rank2")]
names(ranks_model2)[names(ranks_model2) == "var"] <- "feature"
ranks_model2=ranks_model2[order(ranks_model2$rank2),]

ranks_model3=vdata3[c("var","imp3","rank3")]
names(ranks_model3)[names(ranks_model3) == "var"] <- "feature"
ranks_model3=ranks_model3[order(ranks_model3$rank3),]

# save table of ranked features 
table_rankedfeatures <- list('pcr' = ranks_pcr,
                           'comp' = ranks_comp,
                           'model1' = ranks_model1, 
                           'model2' = ranks_model2,
                           'model3' = ranks_model3)
write.xlsx(table_rankedfeatures, file = 'figures/supplementary/s6-7table_rankedfeatures.xlsx')

### Boxplot for host exposure model ###

# Create a list of the top 10 variables
keep_pcr <- ranks_pcr$feature[which(ranks_pcr$pcr_rank<=10)]

# Get the relative importance values for the top 10 features
vinf=lapply(pcr_brts,function(x) x$rinf)
pcr_vinf=do.call(rbind,vinf)
pcr_vinf <- pcr_vinf[which(pcr_vinf$var%in%keep_pcr),]
pcr_vinf$rel.inf <- pcr_vinf$rel.inf/100

# Relabel trait names for boxplots
pcr_vinf$var <- ifelse(pcr_vinf$var=="cites", "Citations", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="max_longevity_d", "Maximum longevity (days)", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="interbirth_interval_d", "Interbirth interval (days)", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="dispersal_km", "Dispersal (km)", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="ed_equal", "Evolutionary distinctiveness", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="upper_elevation_m", "Upper elevation limit (m)", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="island_dwelling", "Island dwelling", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="litters_per_year_n", "Litters per year", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="gestation_length_d", "Gestation length (days)", pcr_vinf$var)
pcr_vinf$var <- ifelse(pcr_vinf$var=="female_maturity_d", "Female maturity (days)", pcr_vinf$var)


# Create grouping variable
pcr_vinf$type <- NA
pcr_vinf$type <- ifelse(pcr_vinf$var=="Citations", "Sampling effort", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Maximum longevity (days)", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Interbirth interval (days)", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Dispersal (km)", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Evolutionary distinctiveness", "Phylogeny", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Upper elevation limit (m)", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Island dwelling", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Litters per year", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Gestation length (days)", "Life history", pcr_vinf$type)
pcr_vinf$type <- ifelse(pcr_vinf$var=="Female maturity (days)", "Life history", pcr_vinf$type)

# Boxplot relative feature importance for the virus isolation model
library(viridis) #https://www.thinkingondata.com/something-about-viridis-library/

boxplot_trait_pcr <- ggplot(pcr_vinf) + ggtitle("(A) Host exposure model") +
        geom_boxplot(aes(x=rel.inf, y=reorder(var,rel.inf), group=var, fill=type), width=0.7, alpha=0.85, linewidth=0.2) +
        theme_bw() +
        labs(x="Relative influence",
             y="Features") + 
        theme(axis.text.y=element_text(size=14),
              axis.text.x=element_text(size=14),
              axis.title.x=element_text(size=20, margin=margin(t=10,r=0,b=0,l=0)),
              axis.title.y=element_text(size=20, margin=margin(t=0,r=10,b=0,l=0)),
              strip.text=element_text(size=20)) +
        scale_fill_manual(values=c("#440154FF","#39568CFF","#1F968CFF")) +
        scale_y_discrete(labels = function(x) str_wrap(x, width = 16))

png("figures/fig3_boxplot_trait_ranking_pcr.png",width=5.7,height=10,units="in",res=600)
boxplot_trait_pcr
dev.off()

### Boxplot for susceptible host model ###

# Create a list of the top 10 variables
keep_comp <- ranks_comp$feature[which(ranks_comp$comp_rank<=10)]

# Get the relative importance values for the top 10 features
vinf=lapply(comp_brts,function(x) x$rinf)
comp_vinf=do.call(rbind,vinf)
comp_vinf <- comp_vinf[which(comp_vinf$var%in%keep_comp),]
comp_vinf$rel.inf <- comp_vinf$rel.inf/100

# Relabel trait names for boxplots
comp_vinf$var <- ifelse(comp_vinf$var=="cites", "Citations", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="dispersal_km", "Dispersal (km)", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="gestation_length_d", "Gestation length (days)", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="upper_elevation_m", "Upper elevation limit (m)", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="fam_FELIDAE", "Family Felidae", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="litter_size_n", "Litters size", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="habitat_breadth_n", "Habitat breadth", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="ed_equal", "Evolutionary distinctiveness", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="det_plantother", "Diet composed of other plant elements (%)", comp_vinf$var)
comp_vinf$var <- ifelse(comp_vinf$var=="altitude_breadth_m", "Altitude breadth (m)", comp_vinf$var)

# Create grouping variable
comp_vinf$type <- NA
comp_vinf$type <- ifelse(comp_vinf$var=="Citations", "Sampling effort", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Dispersal (km)", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Gestation length (days)", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Upper elevation limit (m)", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Family Felidae", "Taxonomy", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Litters size", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Habitat breadth", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Evolutionary distinctiveness", "Phylogeny", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Diet composed of other plant elements (%)", "Life history", comp_vinf$type)
comp_vinf$type <- ifelse(comp_vinf$var=="Altitude breadth (m)", "Life history", comp_vinf$type)

# Boxplot relative feature importance for the virus isolation model
library(viridis)
boxplot_trait_comp <- ggplot(comp_vinf) + ggtitle("(B) Susceptible host model") +
        geom_boxplot(aes(x=rel.inf, y=reorder(var,rel.inf), group=var, fill=type), width=0.7, alpha=0.85, linewidth=0.2) +
        theme_bw() +
        labs(x="Relative influence",
             y="Features") + 
        theme(axis.text.y=element_text(size=14),
              axis.text.x=element_text(size=14),
              axis.title.x=element_text(size=20, margin=margin(t=10,r=0,b=0,l=0)),
              axis.title.y=element_text(size=20, margin=margin(t=0,r=10,b=0,l=0)),
              strip.text=element_text(size=20)) +
        scale_fill_manual(values=c("#440154FF","#39568CFF","#1F968CFF","#73D055FF")) +
        scale_y_discrete(labels = function(x) str_wrap(x, width = 16))

png("figures/fig3_boxplot_trait_ranking_comp.png",width=5.7,height=10,units="in",res=600)
boxplot_trait_comp
dev.off()

### Boxplot for link prediction model 1 ###

# Create a list of the top 10 variables
keep1 <- ranks_model1$feature[which(ranks_model1$rank1<=10)]

# Get the relative importance values for the top 10 features
vinf=lapply(brts1,function(x) x$rinf)
vinf1=do.call(rbind,vinf)
vinf1 <- vinf1[which(vinf1$var%in%keep1),]
vinf1$rel.inf <- vinf1$rel.inf/100

# Relabel trait names for boxplots
vinf1$var <- ifelse(vinf1$var=="cites", "Citations", vinf1$var)
vinf1$var <- ifelse(vinf1$var=="island_dwelling", "Island dwelling", vinf1$var)
vinf1$var <- ifelse(vinf1$var=="dispersal_km", "Dispersal (km)", vinf1$var)

# Create grouping variable for Model 1
vinf1$type <- NA
vinf1$type <- ifelse(vinf1$var=="Citations", "Sampling effort", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC4", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC1", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC3", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC9", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="Island dwelling", "Life history", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC10", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC7", "Viral genomic", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="Dispersal (km)", "Life history", vinf1$type)
vinf1$type <- ifelse(vinf1$var=="PC8", "Viral genomic", vinf1$type)

# Boxplot relative feature importance for model 1
boxplot_trait_model1 <- ggplot(vinf1) + ggtitle("(C) Link prediction model") +
        geom_boxplot(aes(x=rel.inf, y=reorder(var,rel.inf), group=var, fill=type), width=0.7, alpha=0.85, linewidth=0.2) +
        theme_bw() +
        labs(x="Relative influence",
             y="Features") + 
        theme(axis.text.y=element_text(size=14),
              axis.text.x=element_text(size=14),
              axis.title.x=element_text(size=20, margin=margin(t=10,r=0,b=0,l=0)),
              axis.title.y=element_text(size=20, margin=margin(t=0,r=10,b=0,l=0)),
              strip.text=element_text(size=20)) +
        scale_fill_manual(values=c("#440154FF","#1F968BFF","#FDE725FF")) +
        scale_y_discrete(labels = function(x) str_wrap(x, width = 16))

png("figures/fig3_boxplot_trait_ranking_model1.png",width=6.12,height=10,units="in",res=600)
boxplot_trait_model1
dev.off()

### Boxplot for link prediction model 2 ###

# Create a list of the top 10 variables
keep2 <- ranks_model2$feature[which(ranks_model2$rank2<=10)]

# Get the relative importance values for the top 10 features of Model 2
vinf=lapply(brts2,function(x) x$rinf)
vinf2=do.call(rbind,vinf)
vinf2 <- vinf2[which(vinf2$var%in%keep2),]
vinf2$rel.inf <- vinf2$rel.inf/100

# Relabel trait names for boxplots
vinf2$var <- ifelse(vinf2$var=="cites", "Citations", vinf2$var)
vinf2$var <- ifelse(vinf2$var=="island_dwelling", "Island dwelling", vinf2$var)
vinf2$var <- ifelse(vinf2$var=="dispersal_km", "Dispersal (km)", vinf2$var)

# Create grouping variable for Model 2
vinf2$type <- NA
vinf2$type <- ifelse(vinf2$var=="Citations", "Sampling effort", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC4", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC9", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC1", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC10", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC3", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC7", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="PC2", "Viral genomic", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="Island dwelling", "Life history", vinf2$type)
vinf2$type <- ifelse(vinf2$var=="Dispersal (km)", "Life history", vinf2$type)

# Boxplot relative feature importance for model 2
boxplot_trait_model2 <- ggplot(vinf2) + ggtitle("(D) Link prediction model (no vaccinia virus)") +
        geom_boxplot(aes(x=rel.inf, y=reorder(var,rel.inf), group=var, fill=type), width=0.7, alpha=0.85, linewidth=0.2) +
        theme_bw() +
        labs(x="Relative influence",
             y="Features") + 
        theme(axis.text.y=element_text(size=14),
              axis.text.x=element_text(size=14),
              axis.title.x=element_text(size=20, margin=margin(t=10,r=0,b=0,l=0)),
              axis.title.y=element_text(size=20, margin=margin(t=0,r=10,b=0,l=0)),
              strip.text=element_text(size=20)) +
        scale_fill_manual(values=c("#440154FF","#1F968BFF","#FDE725FF")) +
        scale_y_discrete(labels = function(x) str_wrap(x, width = 16)) 

png("figures/other/linkpred/boxplot_trait_ranking_model2.png",width=6.12,height=10,units="in",res=600)
boxplot_trait_model2
dev.off()

### Boxplot for link prediction model 3 ###

# Create a list of the top 10 variables
keep3 <- ranks_model3$feature[which(ranks_model3$rank3<=10)]

# Get the relative importance values for the top 10 features
vinf=lapply(brts3,function(x) x$rinf)
vinf3=do.call(rbind,vinf)
vinf3 <- vinf3[which(vinf3$var%in%keep3),]
vinf3$rel.inf <- vinf3$rel.inf/100

# Relabel trait names for boxplots
vinf3$var <- ifelse(vinf3$var=="cites", "Citations", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="island_dwelling", "Island dwelling", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="fam_FELIDAE", "Family Felidae", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="fam_CAMELIDAE", "Family Camelidae", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="dispersal_km", "Dispersal (km)", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="det_plantother", "Diet composed of other plant elements (%)", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="litter_size_n", "Litter size", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="upper_elevation_m", "Upper elevation (m)", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="altitude_breadth_m", "Altitude breadth (m)", vinf3$var)
vinf3$var <- ifelse(vinf3$var=="female_maturity_d", "Female maturity (days)", vinf3$var)

# Create grouping variable for Model 3
vinf3$type <- NA
vinf3$type <- ifelse(vinf3$var=="Citations", "Sampling effort", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Island dwelling", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Family Felidae", "Taxonomy", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Family Camelidae", "Taxonomy", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Dispersal (km)", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Diet composed of other plant elements (%)", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Litter size", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Upper elevation (m)", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Altitude breadth (m)", "Life history", vinf3$type)
vinf3$type <- ifelse(vinf3$var=="Female maturity (days)", "Life history", vinf3$type)

# Boxplot relative feature importance for model 3
boxplot_trait_model3 <- ggplot(vinf3) + ggtitle("(D) Link prediction model - host traits only") +
        geom_boxplot(aes(x=rel.inf, y=reorder(var,rel.inf), group=var, fill=type), width=0.7, alpha=0.85, linewidth=0.2) +
        theme_bw() +
        labs(x="Relative influence",
             y="Features") + 
        theme(axis.text.y=element_text(size=14),
              axis.text.x=element_text(size=14),
              axis.title.x=element_text(size=20, margin=margin(t=10,r=0,b=0,l=0)),
              axis.title.y=element_text(size=20, margin=margin(t=0,r=10,b=0,l=0)),
              strip.text=element_text(size=20)) +
        scale_fill_manual(values=c("#440154FF","#1F968CFF","#73D055FF")) +
        scale_y_discrete(labels = function(x) str_wrap(x, width = 16)) 

png("figures/supplementary/s5fig_boxplot_trait_ranking_model3.png",width=6.12,height=10,units="in",res=600)
boxplot_trait_model3
dev.off()

#Note: Island dwelling = 20% or more of the breeding range occurs on an island
# https://stats.stackexchange.com/questions/422458/gbm-how-to-interpret-relative-variable-influence

rm(vinf, vinf1, vinf2, vinf3, keep1, keep2, keep3, boxplot_trait_Model1, boxplot_trait_Model2, boxplot_trait_Model3, table_ranks, table_ranks_model1, table_ranks_model2, table_ranks_model3)

```

### *Identify consistently important and unimportant host traits*
Additional Figures: *scatterplot_traitrank_hosttrait.png*, *plot_trait_ranking_link.png*

```{r feat_consistent}

### Host Exposure vs. Susceptible Host Model ###

# Were the rankings of relative feature importance significantly correlated?
ranks=merge(vdata_pcr[c("var","pcr_rank","pcr_imp")],
            vdata_comp[c("var","comp_rank","comp_imp")],
            by="var")
cor.test(ranks$pcr_rank,ranks$comp_rank,method="spearman")

# What if we remove traits with zero/no relative importance and rerank? Are rankings still correlated?
ranks2=ranks[-which(ranks$pcr_imp==0 & ranks$comp_imp==0),]
ranks2=ranks2[order(ranks2$pcr_imp,decreasing=T),]
ranks2$pcr_rank=1:nrow(ranks2)
ranks2=ranks2[order(ranks2$comp_imp,decreasing=T),]
ranks2$comp_rank=1:nrow(ranks2)

cor.test(ranks2$pcr_rank,ranks2$comp_rank,method="spearman")

# Can we identify features with high residuals?
ranks2$resid=abs(resid(lm(comp_rank~pcr_rank,data=ranks2)))  # extract residuals from linear regression as absolute values

# Plot residuals
plot(ranks2$pcr_rank,ranks2$resid,
     ylab="Residuals",xlab="pcr_rank", 
     main="comp_rank")

# Were any residual values greater than 10 or greater than 18? Flag residuals.
#ranks2$select=ifelse(ranks2$resid>10,"yes","no")
ranks2$select=ifelse(ranks2$resid>18,"yes","no")
which(ranks2$resid>20) # returns 9 values

# Were any features consistently high or low ranking across both PCR and virus isolation models? Flag.
n=10
ranks2$select=ifelse(ranks2$comp_rank<=n & ranks2$pcr_rank<=n,"yes",ranks2$select)
ranks2$select=ifelse(ranks2$comp_rank%in%tail(1:nrow(ranks2),n) & ranks2$pcr_rank%in%tail(1:nrow(ranks2),n),"yes",ranks2$select)

# Get the names of consistently high or low ranking features
rset=ranks2
rset$var=ifelse(rset$select=="yes",rset$var,"")

# Plot feature ranking of PCR model against virus isolation model and label traits that were consistently important and unimportant
set.seed(1)
scatterplot_trait_ranking <- ggplot(ranks2,aes(pcr_rank,comp_rank))+
  geom_text_repel(data=rset,aes(label=var),size=2,force=4,direction="both",
                  segment.size=0.5,segment.color="grey")+
  geom_point()+
  scale_y_reverse(limits=c(max(c(ranks2$comp_rank,ranks2$pcr_rank))+4,0))+
  scale_x_reverse(limits=c(max(c(ranks2$comp_rank,ranks2$pcr_rank))+4,0))+
  theme_bw()+
  labs(x="Feature rank for host exposure model",y="Feature rank for susceptible host model")+
  theme(axis.text=element_text(size=10),axis.title=element_text(size=12))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))

png("figures/other/hosttrait/scatterplot_traitrank_hosttrait.png",width=7,height=7,units="in",res=300)
scatterplot_trait_ranking
dev.off()

# Clean environment
rm(rset, n)

### Model 1 vs. Model 2 (Link Prediction Including vs. Excluding VACV links) ###

# Were the rankings of relative feature importance significantly correlated?
ranks=merge(vdata1[c("var","rank1","imp1")],
            vdata2[c("var","rank2","imp2")],
            by="var")
cor.test(ranks$rank1,ranks$rank2,method="spearman")

# What if we remove traits with zero/no relative importance and rerank? Are rankings still correlated?
ranks2=ranks[-which(ranks$imp1==0 & ranks$imp2==0),]
ranks2=ranks2[order(ranks2$imp1,decreasing=T),]
ranks2$rank1=1:nrow(ranks2)
ranks2=ranks[order(ranks2$imp2,decreasing=T),]
ranks2$rank2=1:nrow(ranks2)

cor.test(ranks2$rank1,ranks2$rank2,method="spearman")

# Can we identify features with high residuals?
ranks2$resid=abs(resid(lm(rank2~rank1,data=ranks2)))

# Plot residuals
plot(ranks2$rank1,ranks2$resid,
     ylab="Residuals",xlab="Traits by ranking for Model 1", 
     main="Model 1 with variables with zero/no relative importance removed")

# Were any  residual values greater than 10 or greater than 20? Flag residuals.
ranks2$select=ifelse(ranks2$resid>20,"yes","no")
ranks2[ranks2$resid>20,]

# Were any features consistenly high or low ranking across both infection and competence models? Flag.
n=10
ranks2$select=ifelse(ranks2$rank2<=n & ranks2$rank1<=n,"yes",ranks2$select)
ranks2$select=ifelse(ranks2$rank2%in%tail(1:nrow(ranks2),n) & ranks2$rank1%in%tail(1:nrow(ranks2),n),"yes",ranks2$select)

# Get the names of consistently high or low ranking features
rset=ranks2
rset$var=ifelse(rset$select=="yes",rset$var,"")

# Plot feature ranking of infection model against competence model and label traits that were consistently important and unimportant
set.seed(1)
scatterplot_trait_ranking <- ggplot(ranks2,aes(rank1,rank2))+
  #geom_label(data=rset,aes(label=var),size=2,fill=col,alpha=0.2)+
  geom_text_repel(data=rset,aes(label=var),
                  size=2,
                  force=4,
                  #nudge_y=-2,
                  #nudge_x=1,
                  direction="both",
                  segment.size=0.5,
                  segment.color="grey")+
  geom_point()+
  scale_y_reverse(limits=c(max(c(ranks2$rank2,ranks2$rank1))+4,0))+
  scale_x_reverse(limits=c(max(c(ranks2$rank2,ranks2$rank1))+4,0))+
  #geom_abline(slope=1,linetype=2,size=0.5)+
  theme_bw()+
  labs(x="Feature rank for Model 1 (Full) ",
       y="Feature rank for Model 2 (Partial)")+
  theme(axis.text=element_text(size=10),
        axis.title=element_text(size=12))+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))

png("figures/other/linkpred/plot_trait_ranking_link.png",width=7,height=7,units="in",res=300)
scatterplot_trait_ranking
dev.off()

# Clean environment

```

### *Determine effect directions of each feature on the predicted outcome*
We determine the effect directions of each feature on link prediction using partial dependence plots. These plots allow us to visualize the relationship between a subset of features and the response variable (OPV positivity or host-virus link) while accounting for the average effect of the other predictors in the model.
Additional Figures: *s2fig_plot_pdp_hosttrait.png*, *s3fig_plot_pdp_link.png*

```{r feat_Effect}

# Download library for partial dependence plots
# detach("package:purrr", unload=TRUE)
library(pdp) #partial dependence plots help visualize the relationship b/w a subset of features and the response while accounting for the avg effect of the other predictors in the model
library(gbm)# detach("package:purrr", unload=TRUE)

# Create a function for compiling across BRTs for a given predictor, all else equal
pdp_agg=function(mod,feature){
  
  ## just the plot function
  pdep=plot(mod$mod,feature,
            return.grid=T,
            n.trees=mod$best,
            plot=F,
            continuous.resolution=200,
            type="response")
  
  ## add seed
  pdep$seed=unique(mod$roc$seed)
  
  ## save predictor
  pdep$predictor=pdep[feature][,1]
  
  ## order
  pdep=pdep[order(pdep$predictor),]
  
  ## get rank
  pdep$rank=1:nrow(pdep)
  
  ## save yhat
  pdep$yhat=pdep$y
  
  ## return
  return(pdep)
  
}

# Create a function to plot the PDPs
pdp_plot=function(bmods,feature){
  
  ## pdp_agg
  agg=do.call(rbind,lapply(bmods,function(x) pdp_agg(x,feature)))
  
  ## get class of the feature
  cl=class(data[feature][,1])
  
  ## if else based on type
  if(cl%in%c("numeric","integer")){
    
    ## get element-wise means
    x=with(agg,tapply(predictor,rank,mean))
    y=with(agg,tapply(yhat,rank,mean))
    
    ## save as mean
    pmean=data.frame(predictor=x,yhat=y)
    
    ## get yrange
    yrange=range(agg$yhat,pmean$yhat,na.rm=T)
    
    ## get histogram
    hi=hist(data[feature][,1],breaks=30,plot=F)
    hi=with(hi,data.frame(breaks[1:(length(breaks)-1)],counts))
    names(hi)=c("mids","counts")
    
    ## ggplot it
    ggplot(agg,aes(predictor,yhat,group=seed))+
      
      ## add histogram
      geom_segment(data=hi,inherit.aes=F,
                   aes(x=mids,xend=mids,
                       y=yrange[1],yend=plotrix::rescale(counts,yrange)),
                   size=1,colour="grey",alpha=0.25)+
      
      ## add lines
      geom_line(linewidth=1,alpha=0.25,colour="grey")+
      
      ## add mean
      geom_line(data=pmean,linewidth=1,inherit.aes=F,
                aes(predictor,yhat))+
      
      ## theme
      theme_bw()+
      theme(axis.text=element_text(size=6),
            axis.title=element_text(size=7))+
      theme(axis.title.x=element_text(margin=margin(t=5,r=0,b=0,l=0)))+
      theme(axis.title.y=element_text(margin=margin(t=0,r=5,b=0,l=0)))+
      theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
      labs(x=feature,y="marginal effect")+
      scale_y_continuous(labels=scales::number_format(accuracy=0.01))
    
    ## end numeric
  }else{ ## factor-based plot
    
    ## get element-wise means
    y=with(agg,tapply(yhat,predictor,mean))
    
    ## save as mean
    #pmean=data.frame(predictor=x,yhat=y)
    pmean=data.frame(y)
    names(pmean)="yhat"
    pmean$predictor=rownames(pmean)
    rownames(pmean)=NULL
    
    ## make temp data
    temp=data
    temp$predictor=temp[feature][,1]
    
    ## do nothing
    agg=agg
    pmean=pmean
    temp=temp
    
    ## get yrange
    yrange=range(agg$yhat,pmean$yhat,na.rm=T)
    
    ## fix temp to yrange
    temp$yhat=ifelse(temp$comp==1,max(yrange),min(yrange))
    
    ## ggplot with rug
    set.seed(1)
    ggplot(agg,aes(predictor,yhat,group=seed))+
      
      ## add individual BRTs
      geom_jitter(size=1,alpha=0.25,colour="grey",width=0.1)+
      
      ## add mean
      geom_point(data=pmean,size=2,inherit.aes=F,shape=15,
                 aes(predictor,yhat))+
      
      ## add rug
      geom_rug(data=temp,inherit.aes=F,
               aes(predictor,yhat),
               sides="b",position="jitter",
               colour="grey",alpha=0.25,
               na.rm=T)+
      
      ## theme
      theme_bw()+
      theme(axis.text=element_text(size=6),
            axis.title=element_text(size=7))+
      theme(axis.title.x=element_text(margin=margin(t=5,r=0,b=0,l=0)))+
      theme(axis.title.y=element_text(margin=margin(t=0,r=5,b=0,l=0)))+
      theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
      labs(x=feature,y="marginal effect")+
      scale_y_continuous(limits=c(yrange[1]-0.01,yrange[2]+0.01),
                         labels=scales::number_format(accuracy=0.01))
    
  }
  
}

### Host Trait Models ###

# Load cleaned data file
load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/data/hosttrait_cleandata.RData")
data <- poxdata

# Make binary columns for each taxonomic family in our dataset
dums=fastDummies::dummy_cols(data["fam"])

# Get only unique observations
dums=dums[!duplicated(dums$fam),]

# Ensure all are factor
for(i in 1:ncol(dums)){
  
  ## column as factor
  dums[,i]=factor(dums[,i])
  
}

# Merge family variables with poxdata
data=merge(data,dums,by="fam",all.x=T)
rm(dums)

# Get rank data (as in previous section)
ranks=merge(vdata_pcr[c("var","pcr_rank","pcr_imp")],
            vdata_comp[c("var","comp_rank","comp_imp")],
            by="var")

ranks2=ranks[-which(ranks$pcr_imp==0 & ranks$comp_imp==0),]
ranks2=ranks2[order(ranks2$pcr_imp,decreasing=T),]
ranks2$pcr_rank=1:nrow(ranks2)
ranks2=ranks2[order(ranks2$comp_imp,decreasing=T),]
ranks2$comp_rank=1:nrow(ranks2)

# PDPs for top ranking features of the infection model
ranks2=ranks2[order(ranks2$pcr_rank),]
p1=pdp_plot(pcr_brts,ranks2$var[1])
p2=pdp_plot(pcr_brts,ranks2$var[2])
p3=pdp_plot(pcr_brts,ranks2$var[3])
p4=pdp_plot(pcr_brts,ranks2$var[4])
p5=pdp_plot(pcr_brts,ranks2$var[5])
p6=pdp_plot(pcr_brts,ranks2$var[6])
p7=pdp_plot(pcr_brts,ranks2$var[7])
p8=pdp_plot(pcr_brts,ranks2$var[8])
p9=pdp_plot(pcr_brts,ranks2$var[9])
p10=pdp_plot(pcr_brts,ranks2$var[10])

# PDPs for top ranking features of the competence model
### ALERT: before running the next code chunk, rerun the <pdp_plot> function updating "pcr" to "competence" in the following line of code: "temp$yhat=ifelse(temp$pcr==1,max(yrange),min(yrange))".
ranks2=ranks2[order(ranks2$comp_rank),]
c1=pdp_plot(comp_brts,ranks2$var[1])
c2=pdp_plot(comp_brts,ranks2$var[2])
c3=pdp_plot(comp_brts,ranks2$var[3])
c4=pdp_plot(comp_brts,ranks2$var[4])
c5=pdp_plot(comp_brts,ranks2$var[5])
c6=pdp_plot(comp_brts,ranks2$var[6])
c7=pdp_plot(comp_brts,ranks2$var[7])
c8=pdp_plot(comp_brts,ranks2$var[8])
c9=pdp_plot(comp_brts,ranks2$var[9])
c10=pdp_plot(comp_brts,ranks2$var[10])

# Plot compiled PDPs of the top ranked features for both infection and competence models
library(patchwork)
pdplot_pcr <- p1+p2+p3+p4+p5+p6+p7+p8+p9+p10+plot_layout(nrow=10,ncol=1,byrow=F)
pdplot_comp <- c1+c2+c3+c4+c5+c6+c7+c8+c9+c10+plot_layout(nrow=10,ncol=1,byrow=F)
png("figures/supplementary/s2fig_plot_pdp_hosttrait.png",width=4,height=10,units="in",res=300)
ggarrange(pdplot_pcr,pdplot_comp,ncol=2,nrow=2,widths=c(4,4),heights=c(22,1),
          labels=c("(A) Host exposure model","(B) Susceptible host model"),
          label.x=c(0,-0.1), label.y=0.001,
          font.label=list(face="plain",size=12))
dev.off()

rm(list=setdiff(ls(), c("pcr_brts", "comp_brts", "brts1", "brts2", "brts3",
                        "vinf", "pcr_vinf", "comp_vinf", "vinf1", "vinf2", "vinf3",
                        "vdata_pcr", "vdata_comp", "vdata1", "vdata2", "vdata3")))


### Link Prediction Models ###
# Load cleaned data file
library(fastDummies)
load("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/data/linkpred_cleandata.RData")
data <- linkdata

# Make binary columns for each taxonomic family in our dataset
dums=dummy_cols(data["fam"])

# Get only unique observations
dums=dums[!duplicated(dums$fam),]

# Ensure all are factor
for(i in 1:ncol(dums)){
  ## column as factor
  dums[,i]=factor(dums[,i])
}

# Merge family variables with poxdata
data=merge(data,dums,by="fam",all.x=T)
rm(dums)

# Were the rankings of relative feature importance significantly correlated between Model 1 and Model 2?
ranks=merge(vdata1[c("var","rank1","imp1")],
            vdata2[c("var","rank2","imp2")],
            by="var")

# What if we remove traits with zero/no relative importance and rerank? Are rankings still correlated?
ranks2=ranks[-which(ranks$imp1==0 & ranks$imp2==0),]
ranks2=ranks2[order(ranks2$imp1,decreasing=T),]
ranks2$rank1=1:nrow(ranks2)
ranks2=ranks2[order(ranks2$imp2,decreasing=T),]
ranks2$rank2=1:nrow(ranks2)

cor.test(ranks2$rank1,ranks2$rank2,method="spearman")

### ALERT: before running the next code chunks for Models 1-3, rerun the <pdp_plot> function updating "pcr" to "link" in the following line of code: "temp$yhat=ifelse(temp$pcr==1,max(yrange),min(yrange))".

# PDPs for top ranking features of Model 1
ranks2=ranks2[order(ranks2$rank1),]
a1=pdp_plot(brts1,ranks2$var[1]) #118
a2=pdp_plot(brts1,ranks2$var[2])
a3=pdp_plot(brts1,ranks2$var[3])
a4=pdp_plot(brts1,ranks2$var[4])
a5=pdp_plot(brts1,ranks2$var[5])
a6=pdp_plot(brts1,ranks2$var[6])
a7=pdp_plot(brts1,ranks2$var[7])
a8=pdp_plot(brts1,ranks2$var[8])
a9=pdp_plot(brts1,ranks2$var[9])
a10=pdp_plot(brts1,ranks2$var[10])

# PDPs for top ranking features of Model 2
ranks2=ranks2[order(ranks2$rank2),]
b1=pdp_plot(brts2,ranks2$var[1])
b2=pdp_plot(brts2,ranks2$var[2])
b3=pdp_plot(brts2,ranks2$var[3])
b4=pdp_plot(brts2,ranks2$var[4])
b5=pdp_plot(brts2,ranks2$var[5])
b6=pdp_plot(brts2,ranks2$var[6])
b7=pdp_plot(brts2,ranks2$var[7])
b8=pdp_plot(brts2,ranks2$var[8])
b9=pdp_plot(brts2,ranks2$var[9])
b10=pdp_plot(brts2,ranks2$var[10])

# PDPs for top ranking features of Model 3
ranks3=vdata3[c("var","rank3","imp3")]
ranks3=ranks3[order(ranks3$rank3),]
c1=pdp_plot(brts3,ranks3$var[1])
c2=pdp_plot(brts3,ranks3$var[2])
c3=pdp_plot(brts3,ranks3$var[3])
c4=pdp_plot(brts3,ranks3$var[4])
c5=pdp_plot(brts3,ranks3$var[5])
c6=pdp_plot(brts3,ranks3$var[6])
c7=pdp_plot(brts3,ranks3$var[7])
c8=pdp_plot(brts3,ranks3$var[8])
c9=pdp_plot(brts3,ranks3$var[9])
c10=pdp_plot(brts3,ranks3$var[10])

# Plot compiled PDPs of the top ranked features for both Model 1 and 3
library(patchwork)
m1_pdp_plots <- a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+plot_layout(nrow=10,ncol=1,byrow=F)
m3_pdp_plots <- c1+c2+c3+c4+c5+c6+c7+c8+c9+c10+plot_layout(nrow=10,ncol=1,byrow=F)
png("figures/supplementary/s3fig_plot_pdp_link.png",width=4,height=10,units="in",res=300)
ggarrange(m1_pdp_plots,m3_pdp_plots,ncol=2,nrow=2,widths=c(4,4),heights=c(22,1),
          labels=c("(A) Link prediction","(B) Link prediction trained only on host traits"),
          label.x=c(0,-0.1), label.y=0.001,
          font.label=list(face="plain",size=12))
dev.off()

```

5. PCA Figures
============================================

### *Load required packages and set system*

```{r dim_load, message=FALSE, warning=FALSE}

# Libraries for preparing data for analysis
library(ape)
library(dplyr)
library(nlme)
library(tidyverse)
library(vroom) 
library(readxl)
library(ggplot2)

# Libraries for PCA (principal components analysis)
library(vegan)
library(factoextra) #fviz_eig
library(ggfortify)

# Libraries for MCA
library(FactoMineR)
library(dplyr)
library(factoextra) #fviz_eig

# Library for exporting/saving data
library(openxlsx)

# Clean environment
rm(list=ls()) 
graphics.off()

# Set working directory
setwd("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost")

```

### *Prepare genomic data for PCA*

```{r dim_genes}

# Load genome annotations and trim
genes <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/data/OPVnew_nowwithVirus.xlsx", sheet="PoxHost")

# Rename variables and exclude unnecessary variables
genes <- plyr::rename(genes, c("Virus"="VirusSpecies","Host Genus"="HostGenus","Host Species"="HostSpecies"))
genes <- subset(genes, select=-c(HostSpecies))

# Correct sequence MT903347_1 - 'HostGenus' var lists Family name instead of Genus
genes$HostGenus <- ifelse(genes$HostGenus=="Gliridae","Graphiurus",genes$HostGenus)

# Add unique identifier
genes$rownames <- rownames(genes)
genes$Sequence <- paste(genes$Genome,genes$VirusSpecies,genes$HostGenus,sep="_",genes$rownames)
genes$rownames=NULL
genes <- genes %>% dplyr::select(Sequence, everything())

```

### *PCA of viral accessory genes*

```{r dim_pca}

# Apply PCA using stats::prcomp 
pca <- prcomp(genes[,5:985])      #scaling/centering not appropriate

# Get table of loadings: rotation is the matrix of variable loadings where columns are eigenvectors
loadings <- as.data.frame(pca$rotation)
loadings <- loadings[,c(1:10)]

### Create a df of ranked loadings and their gene names for each PC ###

  # For each PC, create a df of gene loadings named after the PC
  for(i in 1:ncol(loadings)){
    assign(colnames(loadings)[i], data.frame(loadings[,i]))
  }
  
  # Create a list of PC df names
  list <- colnames(loadings)    
  
  # Combine the dfs into a single list; drop PC dfs
  list_df = lapply(list, get)
  rm(list = ls()[grepl("PC", ls())])

  # To each list df, add corresponding gene name; sort in descending order
  for (i in 1:length(list)) {
    colnames(list_df[[i]]) <- "Loadings"
    list_df[[i]]$Gene <- rownames(loadings)
    list_df[[i]]=list_df[[i]][order(-list_df[[i]]$Loadings),]
  }
  
  # Create df of just ranked genes by first dropping loadings from the list
  genes_df <- list_df
  for(i in 1:length(list)) {
    genes_df[[i]]$Loadings=NULL
  }
  
  # Create an empty matrix with PCs as column names
  rank_genes <- data.frame(matrix(ncol=ncol(loadings), nrow=nrow(loadings)))
  colnames(rank_genes) <- colnames(loadings)
  
  # To each matrix column, add the ranked genes for each PC
  for(i in 1:length(list)) {
    rank_genes[,i] = genes_df[[i]]
  }
  
  # Set column names
  rank_genes <- setNames(rank_genes, paste0(names(loadings), '_', 'Gene'))
  
  # Create df of just ranked loadings by first dropping gene names from the list
  loadings_df <- list_df
  for(i in 1:length(list)) {
    loadings_df[[i]]$Gene=NULL
  }
  
  # Create an empty matrix with PCs as column names
  rank_loadings <- data.frame(matrix(ncol=ncol(loadings), nrow=nrow(loadings)))
  colnames(rank_loadings) <- colnames(loadings)
  
  # To each column of the matrix, add the ranked loadings for each PC
  for(i in 1:length(list)) {
    rank_loadings[,i] = loadings_df[[i]]
  }
  
  # Set column names
  rank_loadings <- setNames(rank_loadings, paste0(names(loadings), '_', 'Loadings'))
  
  # Combine dfs of ranked genes and loadings
  rank_PC <- cbind(rank_genes, rank_loadings)
  rank_PC <- rank_PC[,order(colnames(rank_PC))] 
  
  # Reorder columns
  rank_PC <- rank_PC %>% relocate(c("PC10_Gene","PC10_Loadings"), .after = last_col())
  
# Clean environment
rm(list=setdiff(ls(), c("genes","pca","rank_PC")))

```

### *Figure of PCA sequences with three color schemes*
Figures: *sfig7_plot_pca_scoresbyspecies.pdf*
 
```{r dim_pca_viz}

# Choose color palette

  ## Load library
  library(viridis) 
  library(colorspace)

  ## Color-blind friendly palette: viridis w/ gray (#D3D3D3) instead of lime green
  demoplot(c("#30123BFF", "#4454C4FF", "#4490FEFF", "#1FC8DEFF", "#29EFA2FF", 
             "#C1F334FF", "#D3D3D3", "#F1CA3AFF", "#FE922AFF","#EA4F0DFF", 
             "#BE2102FF", "#7A0403FF"), type="bar")
  cbPalette <- c("#30123BFF", "#4454C4FF", "#4490FEFF", "#1FC8DEFF", "#29EFA2FF", 
             "#C1F334FF", "#D3D3D3", "#F1CA3AFF", "#FE922AFF","#EA4F0DFF", 
             "#BE2102FF", "#7A0403FF")
 
# Generate individual scatterplots 
    
  ## Dim 1 and 2
  scores_dim12 <- fviz_pca_ind(pca, axes=c(1,2), title = "",
                  geom.ind = "point", pointshape = 21, pointsize = 2, 
                  fill.ind = genes$VirusSpecies, col.ind = "black", 
                  mean.point=FALSE, #drop centroid
                  label = "var", col.var = "black",repel = TRUE,
                  palette = cbPalette) +
                  xlim(-9, 9) + ylim(-5,5) +
                  theme(legend.position="none")
  
  ## Dim 3 and 4
  scores_dim34 <- fviz_pca_ind(pca, axes=c(3,4), title = "",
                  geom.ind = "point", pointshape = 21, pointsize = 2, 
                  fill.ind = genes$VirusSpecies, col.ind = "black", 
                  mean.point=FALSE, #drop centroid
                  label = "var", col.var = "black",repel = TRUE,
                  palette = cbPalette) +
                  xlim(-11, 11) + ylim(-4,4) +
                  theme(legend.position="none")
  
  ## Dim 5 and 6
  scores_dim56 <- fviz_pca_ind(pca, axes=c(5,6), title = "",
                  geom.ind = "point", pointshape = 21, pointsize = 2, 
                  fill.ind = genes$VirusSpecies, col.ind = "black", 
                  mean.point=FALSE, #drop centroid
                  label = "var", col.var = "black",repel = TRUE,
                  palette = cbPalette) +
                  xlim(-6, 6) + ylim(-8,8) +
                  theme(legend.position="none")
  
  ## Dim 7 and 8
  scores_dim78 <- fviz_pca_ind(pca, axes=c(7,8), title = "",
                  geom.ind = "point", pointshape = 21, pointsize = 2, 
                  fill.ind = genes$VirusSpecies, col.ind = "black", 
                  mean.point=FALSE, #drop centroid
                  label = "var", col.var = "black",repel = TRUE,
                  palette = cbPalette) +
                  xlim(-4, 4) + ylim(-4,4) +
                  theme(legend.position="none")

  ## Dim 9 and 10
  scores_dim910 <- fviz_pca_ind(pca, axes=c(9,10), title = "",
                   geom.ind = "point", pointshape = 21, pointsize = 2, 
                   fill.ind = genes$VirusSpecies, col.ind = "black", 
                   mean.point=FALSE, #drop centroid
                   label = "var", col.var = "black",repel = TRUE,
                   palette = cbPalette) +
                   xlim(-4, 4) + ylim(-4,4) +
                   theme(legend.position="none")

  ## Get legend only
  legend <- cowplot::get_legend(fviz_pca_ind(pca, axes=c(9,10),
                  geom.ind = "point", pointshape = 21, pointsize = 2, 
                  fill.ind = genes$VirusSpecies, col.ind = "black", 
                  addEllipses = TRUE,label = "var", col.var = "black",repel = TRUE,
                  legend.title = "OPV species",
                  palette = cbPalette))
  
# Combine plots and save
  library(cowplot)
  pdf("figures/supplementary/s7fig_plot_pca_scoresbyspecies.pdf", width=8,height=8)
  plot_grid(scores_dim12, scores_dim34, scores_dim56, scores_dim78, scores_dim910, legend, ncol=3, nrow=2, scale=c(0.9), labels = c('A','B','C','D','E',''))  
  dev.off()

```

### *Combine genes and their loadings with their predicted functional roles*
Note: The file, "data/PCA_Gene_contributions-classification.xlsx", contains the predicted functional roles for a subset of accessory genes. Here, we clean the datafile and merge it with the complete list of accessory genes.

```{r dim_pca_viz}

library(readxl)

# Read in function data (compiled by H.)
 
    # For PC1 positive and negative loadings: read in data, rename columns, and merge
    pc1_fnx_pos <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC1")[,1:3]
    pc1_fnx_neg <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC1")[,c(7,9,10)]
  
    # For PC3 posi;tive and negative loadings: read in data, rename columns, and merge
    pc3_fnx_pos <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC3")[,1:3]
    pc3_fnx_neg <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC3")[,7:8]
    pc3_fnx_neg$role <- NA
  
    # For PC4 positive and negative loadings: read in data, rename columns, and merge
    pc4_fnx_pos <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC4")[,1:3]
    pc4_fnx_neg <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC4")[,8:10]
  
    # For PC9 positive and negative loadings: read in data, rename columns, and merge
    pc9_fnx_pos <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC9")[,1:3]
    pc9_fnx_neg <- read_xlsx("data/PCA_Gene_contributions-classification.xlsx", sheet="PC9")[,7:9]

# Correct names of gene functions
  
    # Create a list of the positive and negative loadings
    list_df <- list(pc1_fnx_pos=data.frame(pc1_fnx_pos), pc1_fnx_neg=data.frame(pc1_fnx_neg),
                    pc3_fnx_pos=data.frame(pc3_fnx_pos), pc3_fnx_neg=data.frame(pc3_fnx_neg),
                    pc4_fnx_pos=data.frame(pc4_fnx_pos), pc4_fnx_neg=data.frame(pc4_fnx_neg),
                    pc9_fnx_pos=data.frame(pc9_fnx_pos), pc9_fnx_neg=data.frame(pc9_fnx_neg))
  
    # For each object in the list, rename columns and remove NAs
    for (i in seq_along(list_df)){
        colnames(list_df[[i]]) <- c("gene","protein","role")
        list_df[[i]] <- list_df[[i]] %>% filter(!is.na(list_df[[i]]$gene))
    }    
    
    # For each object in the list, get the names of each unique function
    list_names <- list()
    for(i in seq_along(list_df)) {
         list_names[[i]] <- unique(list_df[[i]]$role)
    }
    
    # Unlist names and view to identify mistakes in spelling
    list_names <- unlist(list_names)
    unique(list_names)
    
    # Correct naming of functions
    list_names <- list()
    for(i in seq_along(list_df)) {
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Viron/Membrane"|list_df[[i]]$role =="Virion/Membrane", 
                                    "Virus structure", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Cytokine/chemokine regulation"|list_df[[i]]$role =="Ckemokine/cytokine regulation", 
                                    "Chemokine/cytokine regulation", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Ckemokine/cytokine regulation", 
                                    "Chemokine/cytokine regulation", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Virus Entry", "Virus entry", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Cell death/ cell cycle regulation", 
                                    "Cell death/cell cycle regulation", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Kelch-Like Protein"|list_df[[i]]$role =="Kelch-like Protein", 
                                    "Kelch-like protein", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="DNA Replication", 
                                    "DNA replication", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="RNA/Transcription/Translation", 
                                    "RNA/transcription/translation", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Addaptive immunity/Anitibody"|list_df[[i]]$role =="Addaptive Immunity"|list_df[[i]]$role =="Adaptive immunity/ Antibody"|list_df[[i]]$role =="Adaptive immunity/Anitibody"|list_df[[i]]$role =="Addaptive immunity/ Antibody", 
                                    "Antagonizing host adaptive immunity", list_df[[i]]$role)
        list_df[[i]]$role <- ifelse(list_df[[i]]$role =="Unknown", 
                                    "Unknown function", list_df[[i]]$role)
        list_names[[i]] <- unique(list_df[[i]]$role)
    }
  
    # Check names of each function again
    list_names <- unlist(list_names)
    unique(list_names)

# Remove identical rows of data
    
    # Combine list of dfs into a single df
    gene_roles <- rbind(list_df[[1]], list_df[[2]], list_df[[3]], list_df[[4]], list_df[[5]], list_df[[6]], list_df[[7]], list_df[[8]])
    
    # Reorder rows by gene name
    gene_roles <- gene_roles[order(gene_roles$gene),]
    
    # Remove identical rows
    gene_roles <- gene_roles %>% distinct()

# Identify and resolve genes with conflicting classified functions
    
    # Identify genes with conflicting roles
    dup <- gene_roles$gene[duplicated(gene_roles$gene)]
    gene_roles_dup <- gene_roles[dup,]
    gene_roles_dup <- gene_roles[gene_roles$gene %in% dup,]
    
    # Save and send to H. Koehler for corrections
    # write.csv(gene_roles_dup, "figures/other/gene_roles_dup.csv")  
    
    # Resolve conflicting functions for 18 genes
    gene_roles$role = ifelse(gene_roles$gene=="ABH08089.1" & gene_roles$role=="Unknown function", 
                             "Chemokine/cytokine regulation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="ADZ29284.1" & gene_roles$role=="Chemokine/cytokine regulation", 
                             "Pathogen recognition", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="ADZ29296.1" & gene_roles$role=="Pathogen recognition", 
                             "Chemokine/cytokine regulation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="ADZ29950.1" & gene_roles$role=="Kelch-like protein", 
                             "Unknown function", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="AGF36812.1" & is.na(gene_roles$role), 
                             "Unknown function", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="AGR34497.1" & gene_roles$role=="Unknown function", 
                             "RNA/transcription/translation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="AGY97404.1" & gene_roles$role=="Unknown function", 
                             "Chemokine/cytokine regulation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="AIF30225.1" & gene_roles$role=="Unknown function", 
                             "Virus entry", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="ATB56114.1" & gene_roles$role=="Unknown function", 
                             "Cell death/cell cycle regulation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="AZY89837.1" & gene_roles$role=="Unknown function", 
                             "Virus structure", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="QNP12344.1" & gene_roles$role=="Unknown function", 
                             "Kelch-like protein", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="QQA05182.1" & is.na(gene_roles$role), 
                             "Virus structure", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="QQA05677.1" & gene_roles$role=="Pathogen recognition", 
                             "Chemokine/cytokine regulation", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="SNB48439.1" & gene_roles$role=="Unknown function", 
                             "DNA replication", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="SNB50617.1" & gene_roles$role=="Virion (in an infectious virus particle)", 
                             "Unknown function", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="SNB57100.1" & is.na(gene_roles$role), 
                             "Unknown function", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="SNB63702.1" & gene_roles$role=="Chemokine/cytokine regulation", 
                             "Antagonizing host adaptive immunity", gene_roles$role)
    gene_roles$role = ifelse(gene_roles$gene=="SPN68081.1" & gene_roles$role=="RNA/transcription/translation", 
                             "Unknown function", gene_roles$role)

    # Drop duplicates (18 rows)
    gene_roles <- gene_roles[!duplicated(gene_roles$gene),]

# Merge df <gene_roles> with all genes
    
    # Create new df <genes_df> and get all gene names into a single column
    genes_df <- as.data.frame(colnames(genes))
    genes_df <- as.data.frame(genes_df[-(1:4),])
    colnames(genes_df) <- c('gene')
    
    # Merge using 'join' function to keep the original order of the genes
    genes_df <- plyr::join(genes_df, gene_roles)
    
    # Replace NA with 'Not classified'
    genes_df$role <- ifelse(is.na(genes_df$role),"Not classified",genes_df$role)

```

### *Extract influential genes based on loading values*

```{r}

# For each PC, extract the genes that are greater than (mean+1.5*sd) and less than (mean-1.5*sd)

# PC1 loadings
pc1 <- rank_PC[,1:2]
colnames(pc1) <- c("gene", "loading")
sd <- sd(pc1$loading)
pc1_pos <- pc1 %>% filter(loading > (mean(pc1$loading)+1.5*sd))
pc1_neg <- pc1 %>% filter(loading < (mean(pc1$loading)-1.5*sd))
pc1_gene <- c(pc1_pos$gene, pc1_neg$gene)

# PC2 loadings
pc2 <- rank_PC[,3:4]
colnames(pc2) <- c("gene", "loading")
sd <- sd(pc2$loading)
pc2_pos <- pc2 %>% filter(loading > (mean(pc2$loading)+1.5*sd))
pc2_neg <- pc2 %>% filter(loading < (mean(pc2$loading)-1.5*sd))
pc2_gene <- c(pc2_pos$gene, pc2_neg$gene)

# PC3 loadings
pc3 <- rank_PC [,5:6]
colnames(pc3) <- c("gene", "loading")
sd <- sd(pc3$loading)
pc3_pos <- pc3 %>% filter(loading > (mean(pc3$loading)+1.5*sd))
pc3_neg <- pc3 %>% filter(loading < (mean(pc3$loading)-1.5*sd))
pc3_gene <- c(pc3_pos$gene, pc3_neg$gene)

# PC4 loadings
pc4 <- rank_PC [,7:8]
colnames(pc4) <- c("gene", "loading")
sd <- sd(pc4$loading)
pc4_pos <- pc4 %>% filter(loading > (mean(pc4$loading)+1.5*sd))
pc4_neg <- pc4 %>% filter(loading < (mean(pc4$loading)-1.5*sd))
pc4_gene <- c(pc4_pos$gene, pc4_neg$gene)

# PC5 loadings
pc5 <- rank_PC [,9:10]
colnames(pc5) <- c("gene", "loading")
sd <- sd(pc5$loading)
pc5_pos <- pc5 %>% filter(loading > (mean(pc5$loading)+1.5*sd))
pc5_neg <- pc5 %>% filter(loading < (mean(pc5$loading)-1.5*sd))
pc5_gene <- c(pc5_pos$gene, pc5_neg$gene)

# PC6 loadings
pc6 <- rank_PC [,11:12]
colnames(pc6) <- c("gene", "loading")
sd <- sd(pc6$loading)
pc6_pos <- pc6 %>% filter(loading > (mean(pc6$loading)+1.5*sd))
pc6_neg <- pc6 %>% filter(loading < (mean(pc6$loading)-1.5*sd))
pc6_gene <- c(pc6_pos$gene, pc6_neg$gene)

# PC7 loadings
pc7 <- rank_PC [,13:14]
colnames(pc7) <- c("gene", "loading")
sd <- sd(pc7$loading)
pc7_pos <- pc7 %>% filter(loading > (mean(pc7$loading)+1.5*sd))
pc7_neg <- pc7 %>% filter(loading < (mean(pc7$loading)-1.5*sd))
pc7_gene <- c(pc7_pos$gene, pc7_neg$gene)

# PC8 loadings
pc8 <- rank_PC [,15:16]
colnames(pc8) <- c("gene", "loading")
sd <- sd(pc8$loading)
pc8_pos <- pc8 %>% filter(loading > (mean(pc8$loading)+1.5*sd))
pc8_neg <- pc8 %>% filter(loading < (mean(pc8$loading)-1.5*sd))
pc8_gene <- c(pc8_pos$gene, pc8_neg$gene)

# PC9 loadings
pc9 <- rank_PC [,17:18]
colnames(pc9) <- c("gene", "loading")
sd <- sd(pc9$loading)
pc9_pos <- pc9 %>% filter(loading > (mean(pc9$loading)+1.5*sd))
pc9_neg <- pc9 %>% filter(loading < (mean(pc9$loading)-1.5*sd))
pc9_gene <- c(pc9_pos$gene, pc9_neg$gene)

# PC10 loadings
pc10 <- rank_PC [,19:20]
colnames(pc10) <- c("gene", "loading")
sd <- sd(pc10$loading)
pc10_pos <- pc10 %>% filter(loading > (mean(pc10$loading)+1.5*sd))
pc10_neg <- pc10 %>% filter(loading < (mean(pc10$loading)-1.5*sd))
pc10_gene <- c(pc10_pos$gene, pc10_neg$gene)

## Reclassify gene functions into simplified roles to create fewer groups for plotting
    
# Get function names
unique(genes_df$role)

# Create new group 'Host interaction and immune evasion'
genes_df$role_simple <- genes_df$role
genes_df$role_simple <- ifelse(genes_df$role_simple=="Antagonizing host adaptive immunity"|
                        genes_df$role_simple=="Chemokine/cytokine regulation"|
                        genes_df$role_simple=="Cell death/cell cycle regulation"|
                        genes_df$role_simple=="Pathogen recognition"|
                        genes_df$role_simple=="Kelch-like protein",
                        "Host interaction and immune evasion",genes_df$role_simple)

# Create new group 'Virus replication and gene expression'
genes_df$role_simple <- ifelse(genes_df$role_simple=="DNA replication"|
                        genes_df$role_simple=="RNA/transcription/translation",
                        "Virus replication and gene expression",genes_df$role_simple)

# Create new group 'Virus structure and entry'
genes_df$role_simple <- ifelse(genes_df$role_simple=="Virus entry"|
                        genes_df$role_simple=="Virus structure",
                        "Virus structure and entry",genes_df$role_simple)

# Create new group 'Unknown function'
genes_df$role_simple <- ifelse(genes_df$role_simple=="Unknown function"|
                        genes_df$role_simple=="Not classified",
                        "Unknown function",genes_df$role_simple)

# Check function names
unique(genes_df$role_simple)
   
```

### *Figure of PCA loadings*

```{r}
 
# Create loading plots by gene function
  
  ## Create color-blind friendly palette based on number of roles excluding 'Not classified'
      
    # Get libraries
    library(viridis)
    library(rcartocolor)
    library(colorspace) #demoplot
    
    # Create df of functional roles to which we will add a corresponding color/hex code
    cbPalette <- as.data.frame(sort(unique(genes_df$role_simple)))
    colnames(cbPalette) <- c("role")
    
    # Explore color palettes using <carto_pal>: select 5 colors
    demoplot(carto_pal(6, "Safe"), type="bar")
    print(carto_pal(6,"Safe"))
    demoplot(c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#888888"), type="bar")
      ## blue, pink, yellow, green, light gray
    
  ## PC1 and PC2
      
    # get names of genes important to PC1 and PC2
    pc12_gene <- unique(c(pc1_gene, pc2_gene))

    # subset genes_df to include only those important to PC1 and PC2
    genes_df_pc12 <- genes_df[genes_df$gene %in% pc12_gene,]

    # check that all 5 gene functions are present for these dimensions
    sort(unique(genes_df_pc12$role_simple))

    # plot
    plot_pc12 <- fviz_pca_var(pca, axes = c(1, 2),
                 col.var = genes_df$role_simple,
                 fill.var = genes_df$role_simple,
                 palette = c( "#117733", "#88CCEE",  "#888888", "#CC6677", "#DDCC77"), title="",
                 arrowsize = 0.3,
                 repel = TRUE, labelsize=1,label="none",
                 select.var=list(name=pc12_gene)) +
                 xlim(-0.4, 0.4) + ylim(-0.45,0.45) +
                 theme(legend.position="right")
     
  ## PC3 and PC4
      
    # get names of genes important to PC3 and PC4
    pc34_gene <- unique(c(pc3_gene, pc4_gene))
    
    # subset genes_df to include only those important to PC3 and PC4
    genes_df_pc34 <- genes_df[genes_df$gene %in% pc34_gene,]
    
    # check that all 5 gene functions are present for these dimensions
    sort(unique(genes_df_pc34$role_simple))

    # plot
    plot_pc34 <- fviz_pca_var(pca, axes = c(3, 4),
                 col.var = genes_df$role_simple,
                 fill.var = genes_df$role_simple,
                 palette = c( "#117733", "#88CCEE",  "#888888", "#CC6677", "#DDCC77"), title="",
                 arrowsize = 0.3,
                 repel = TRUE, labelsize=1, label="none",
                 select.var=list(name=pc34_gene)) +
                 xlim(-0.3, 0.3) + ylim(-0.4,0.4) +
                 theme(legend.position="right")

    ## PC5 and PC6
      
    # get names of genes important to PC5 and PC6
    pc56_gene <- unique(c(pc5_gene, pc6_gene))
    
    # subset genes_df to include only those important to PC5 and PC6
    genes_df_pc56 <- genes_df[genes_df$gene %in% pc56_gene,]
    
    # check that all 5 gene functions are present for these dimensions
    sort(unique(genes_df_pc56$role_simple))

    # plot
    plot_pc56 <- fviz_pca_var(pca, axes = c(5, 6),
                 col.var = genes_df$role_simple,
                 fill.var = genes_df$role_simple,
                 palette = c( "#117733", "#88CCEE",  "#888888", "#CC6677", "#DDCC77"), title="",
                 arrowsize = 0.3,
                 repel = TRUE, labelsize=1, label="none",
                 select.var=list(name=pc56_gene)) +
                 xlim(-0.25, 0.25) + ylim(-0.2,0.2) +
                 theme(legend.position="right")
    
  ## PC7 and PC8
      
    # get names of genes important to PC7 and PC8
    pc78_gene <- unique(c(pc7_gene, pc8_gene))
    
    # subset genes_df to include only those important to PC7 and PC8
    genes_df_pc78 <- genes_df[genes_df$gene %in% pc78_gene,]
    
    # check that all 5 gene functions are present for these dimensions
    sort(unique(genes_df_pc78$role_simple))

    # plot
    plot_pc78 <- fviz_pca_var(pca, axes = c(7, 8),
                 col.var = genes_df$role_simple,
                 fill.var = genes_df$role_simple,
                 palette = c( "#117733", "#88CCEE",  "#888888", "#CC6677", "#DDCC77"), title="",
                 arrowsize = 0.3,
                 repel = TRUE, labelsize=1, label="none",
                 select.var=list(name=pc78_gene)) +
                 xlim(-0.3, 0.3) + ylim(-0.3,0.3) +
                 theme(legend.position="bottom")

  ## PC9 and PC10
      
    # get names of genes important to PC9 and PC10
    pc910_gene <- unique(c(pc9_gene, pc10_gene))
    
    # subset genes_df to include only those important to PC9 and PC10
    genes_df_pc910 <- genes_df[genes_df$gene %in% pc910_gene,]
    
    # check that all 5 gene functions are present for these dimensions
    sort(unique(genes_df_pc910$role_simple)) #yes
    
    # plot
    plot_pc910 <- fviz_pca_var(pca, axes = c(9, 10),
                  col.var = genes_df$role_simple,
                  fill.var = genes_df$role_simple,
                 palette = c( "#117733", "#88CCEE",  "#888888", "#CC6677", "#DDCC77"), title="",
                  arrowsize = 0.3,
                  repel = TRUE, labelsize=1, label="none",
                  select.var=list(name=pc910_gene)) +
                  xlim(-0.25, 0.25) + ylim(-0.2,0.2) +
                  theme(legend.position="bottom")

  ## Get legend only
  legend <- cowplot::get_legend(fviz_pca_var(pca, axes = c(9, 10),
               col.var = genes_df$role_simple,
               arrowsize = 0.3,
               repel = TRUE, labelsize=1, label="none",
               select.var=list(name=pc910_gene)) +
               scale_color_manual(name = "Gene predicted function", labels = c("Ankyrin", "Host interaction and immune evasion", "Viral replication and gene expression", "Virus structure and entry", "Unknown function"),
                    values= c("#117733", "#88CCEE", "#CC6677", "#DDCC77", "#888888")))

  ## Remove legends from loading plots
  plot_pc12 <- plot_pc12 + theme(legend.position="none")
  plot_pc34 <- plot_pc34 + theme(legend.position="none")
  plot_pc56 <- plot_pc56 + theme(legend.position="none")
  plot_pc78 <- plot_pc78 + theme(legend.position="none")
  plot_pc910 <- plot_pc910 + theme(legend.position="none")

  ## Combine biplots and save
  library(cowplot)
  pdf("figures/supplementary/s6fig_plot_pca_loadingsbyrole.pdf", width=10,height=8)
  plot_grid(plot_pc12, plot_pc34, plot_pc56, plot_pc78, plot_pc910, legend, 
            ncol=3, nrow=2, 
            scale=c(0.9), 
            labels = c('A','B','C','D','E',''))  
  dev.off()  

# Save dataset of the most influential genes, their loadings, and their functional roles

  ## Create list of lists of positive and negative loadings for most influential genes
  list_df <- list(pc1_pos=data.frame(pc1_pos), pc1_neg=data.frame(pc1_neg),
                  pc3_pos=data.frame(pc3_pos), pc3_neg=data.frame(pc3_neg),
                  pc4_pos=data.frame(pc4_pos), pc4_neg=data.frame(pc4_neg),
                  pc9_pos=data.frame(pc9_pos), pc9_neg=data.frame(pc9_neg))
  
  ## Join function data with loading data
  for (i in seq_along(list_df)) {
    list_df[[i]] <- left_join(list_df[[i]], genes_df, by = join_by(gene))
    list_df[[i]]$rank = 1:nrow(list_df[[i]])
    list_df[[i]] <- list_df[[i]][, c("rank", "gene", "loading", "protein", "role", "role_simple")]
  }

  ## Export
  library(openxlsx)
  write.xlsx(list_df, file='figures/supplementary/s1data_rankedgenes.xlsx')

# Clean environment
rm(list=setdiff(ls(), c("genes","pca", "genes_df",
                        "pc1_pos", "pc1_neg",
                        "pc3_pos", "pc3_neg",
                        "pc4_pos", "pc4_neg",
                        "pc9_pos", "pc9_neg")))

```


### Figure 4 - Spiderplot

```{r}

library(ggplot2)
library(fmsb)
library(readxl)

pc1_pos <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc1_pos")

pc1_neg <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc1_neg")

pc3_pos <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc3_pos")

pc3_neg <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc3_neg")

pc4_pos <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc4_pos")

pc4_neg <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc4_neg")

pc9_pos <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc9_pos")

pc9_neg <- read_xlsx("/Users/katietseng/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/figures/supplementary/s1data_rankedgenes.xlsx", sheet="pc9_neg")

# pc_list <- list(pc1_pos, pc1_neg, pc3_pos, pc3_neg, pc4_pos, pc4_neg, pc9_pos, pc9_neg)
# pc_list <- lapply(pc_list, function(x) x <- as.data.frame(table(x$role_simple)))
# 
pc1_pos <- as.data.frame(table(pc1_pos$role_simple))
pc1_neg <- as.data.frame(table(pc1_neg$role_simple))
pc1 <- cbind(pc1_pos, pc1_neg$Freq)
pc1$count <- pc1$Freq+pc1$`pc1_neg$Freq`

pc3_pos <- as.data.frame(table(pc3_pos$role_simple))
pc3_neg <- as.data.frame(table(pc3_neg$role_simple))
pc3 <- cbind(pc3_pos, pc3_neg$Freq)
pc3$count <- pc3$Freq+pc3$`pc3_neg$Freq`

pc4_pos <- as.data.frame(table(pc4_pos$role_simple))
pc4_neg <- as.data.frame(table(pc4_neg$role_simple))
pc4 <- cbind(pc4_pos, pc4_neg$Freq)
pc4$count <- pc4$Freq+pc4$`pc4_neg$Freq`

pc9_pos <- as.data.frame(table(pc9_pos$role_simple))
pc9_neg <- as.data.frame(table(pc9_neg$role_simple))
pc9 <- cbind(pc9_pos, pc9_neg$Freq)
pc9$count <- pc9$Freq+pc9$`pc9_neg$Freq`

PCs <- data.frame(
  row.names = c("PC1", "PC3", "PC4", "PC9"),
  Ankyrins = c(pc1[1,4], pc3[1,4], pc4[1,4], pc9[1,4]),
  Immune = c(pc1[2,4], pc3[2,4], pc4[2,4], pc9[2,4]),
  Unknown = c(pc1[3,4], pc3[3,4], pc4[3,4], pc9[3,4]),
  Replication = c(pc1[4,4], pc3[4,4], pc4[4,4], pc9[4,4]),
  Structure = c(pc1[5,4], pc3[5,4], pc4[5,4], pc9[5,4])
)

# PCs <- data.frame(
#   row.names = c("PC1", "PC3", "PC4", "PC9"),
#   Ankyrins = c(14, 14, 11, 13),
#   Immune = c(29, 33, 32, 29),
#   Unknown = c(55, 36, 26, 23),
#   Replication = c(15, 15, 8, 6),
#   Structure = c(25, 30, 12, 18)
# )

# Define the variable ranges: maximum and minimum
max_min <- data.frame(
  Ankyrins = c(60, 0), Immune = c(60, 0), Unknown = c(60, 0),
  Replication = c(60, 0), Structure = c(60, 0)
)
# Bind the variable ranges to the data
df <- rbind(max_min, PCs)
df #check that it makes sense

#individual plots
PC1_data <- df[c("Max", "Min", "PC1"), ]
PC3_data <- df[c("Max", "Min", "PC3"), ]
PC4_data <- df[c("Max", "Min", "PC4"), ]
PC9_data <- df[c("Max", "Min", "PC9"), ]

#but make it pretty
madameweb <- function(data, vlabels = colnames(data), vlcex = 0.7,
    caxislabels = NULL, title = NULL, ...){
    radarchart(
    data, axistype = 1,
    # Customize the polygon
    pcol = color, pfcol = scales::alpha(color, 0.5), plwd = 2, plty = 1,
    # Customize the grid
    cglcol = "black", cglty = 1, cglwd = 0.8,
    # Customize the axis
    axislabcol = "black", 
    # Variable labels
    vlcex = vlcex, vlabels = vlabels,
    caxislabels = caxislabels, title = title, ...
  )
}

# Define colors and titles
colors <- c("#EF9B42", "#A92C2A", "#162667", "#3A7889") #manual MoMA Colors OKeeffe
titles <- c("PC1", "PC3", "PC4", "PC9")

# Reduce plot margin using par()
# Split the screen in 4 parts
op <- par(mar = c(1, 1, 1, 1))
par(mfrow = c(1,4))

# Create the radar chart
for(i in 1:4){
  # create_beautiful_radarchart(
    madameweb(
      data = df[c(1, 2, i+2), ], caxislabels = c(0, 15, 30, 45, 60),
    color = colors[i], title = titles[i]
  )
}
par(op)

```
