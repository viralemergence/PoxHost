---
title: "Dimensionality Reduction"
output:
  pdf_document: default
  word_document: default
  html_document: default
date: '2022-11-07'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages, clean environment, and set working directory

```{r prep_load}

#(1) Libraries for preparing data for analysis
library(ape)
library(dplyr)
library(nlme)
library(tidyverse)
library(vroom) 
## treespace dependencies include XQuartz v2.7.11 (https://www.xquartz.org/releases/XQuartz-2.7.11.html) and 'rgl' (https://stackoverflow.com/a/66127391/2554330)
## recommend installing and loading rgl including 'options(rgl.useNULL=TRUE)' below before loading treespace
library(rgl) # > install.packages("rgl"); > options(rgl.useNULL=TRUE)
library(treespace) 
library(readxl)
library(ggplot2)

#(2) Clean environment
rm(list=ls()) 
graphics.off()

# Set working directory
setwd("~/Library/CloudStorage/OneDrive-WashingtonStateUniversity(email.wsu.edu)/Fernandez Lab/Projects (Active)/OPV Host Prediction/GitHub/PoxHost/Tseng2022/Link Prediction Model")

```

### Load and explore genome annotations

```{r prep_genes}

#(1) Load genome annotations and trim
genes <- read_xlsx("OPVnew_nowwithVirus.xlsx", sheet="PoxHost")

#(2) Subset
genes <- plyr::rename(genes, c("Virus"="VirusSpecies","Host Genus"="HostGenus","Host Species"="HostSpecies"))
genes <- subset(genes, select=-c(HostSpecies))

#(3) Correct sequence MT903347_1 - 'HostGenus' var lists Family name instead of Genus
genes$HostGenus <- ifelse(genes$HostGenus=="Gliridae","Graphiurus",genes$HostGenus)

#(3) Add unique identifier
genes$rownames <- rownames(genes)
genes$Sequence <- paste(genes$Genome,genes$VirusSpecies,genes$HostGenus,sep="_",genes$rownames)
genes$rownames=NULL
genes <- genes %>% dplyr::select(Sequence, everything())

################################################################################
#INVESTIGATED outcome of PCA when we drop accessory genes present in only one virus species and when we drop identical (duplicate) observations of the same host-virus. Results suggest that inclusion of all variables and all observations captured greater proportion of variance.
################################################################################
# #(4) Drop accessory genes that are present in only one virus species (all 0's except for one)
# genes <- genes[c(1:4,4 + which(colSums(genes[-(1:4)])>1))]
# ### 985 variables to 686 variables
# 
# #(5) Identify observations of the same host-virus links with identical presence/absence of accessory genes 
# genes$dup <- duplicated(genes[,-c(1:2)])
# table(genes$dup)
# ### 42 dups
# 
# #(6) Drop duplicate observations
# genes <- genes[genes$dup==FALSE,]
# genes$dup=NULL
# ### 197 obs to 155 obs
################################################################################

#(7) View frequency of various virus species
prop_table <- subset(genes, select=-c(Sequence,Genome))
prop_table$Frequency = 1 
prop_table <- aggregate(Frequency ~ VirusSpecies + HostGenus, data=prop_table, FUN=sum)
prop_table <- prop_table[order(prop_table[,c("VirusSpecies")],prop_table[,c("HostGenus")]) ,]
prop_table$Perc <- prop_table$Frequency/sum(prop_table$Frequency)*100
print(prop_table)

#(8) Save frequency table to Output folder
# write.csv(table, "Output/gene_freq_table.csv")

#(9) To assess variation in the presence/absence of OPV genes, create mode function
mode.prop <- function(x) {                
  ux <- unique(x[is.na(x)==FALSE])        # creates array of unique values
  tab <- tabulate(match(na.omit(x), ux))  # creates array of the frequency a unique value appears in a column 
  max(tab)/length(x[is.na(x)==FALSE])     # max-frequency / number of elements in each column that are not NA
}

#(10) Assess variation across columns (2 indicates columns)
vars=data.frame(apply(genes,2,function(x) mode.prop(x)),
                apply(genes,2,function(x) length(unique(x)))) # number of unique elements in each column
vars$variables=rownames(vars)
colnames(vars) <- c("var","uniq","column")

#(11) Trim
vars <- vars[-c(1,2), ]

#(12) Any variables with no variation? If so drop
which(vars$var==1)
# vars <- subset(vars,vars$var<1)

#(13) Visualize distribution of variation
#png("Output/gene_variation.png", width=4,height=4,units="in",res=600)
gene_var <- ggplot(vars,
       aes(var))+
  geom_histogram(bins=50)+
  geom_vline(xintercept=0.70,linetype=2,size=0.5)+
  theme_bw()+
  theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank())+
  theme(axis.title.x=element_text(margin=margin(t=10,r=0,b=0,l=0)))+
  theme(axis.title.y=element_text(margin=margin(t=0,r=10,b=0,l=0)))+
  labs(y="frequency",
       x="variation in the presence/absence of genes across genome sequences")+
  scale_x_continuous(labels=scales::percent)

#dev.off()
gene_var

#(16) clean environment
rm(prop_table, vars, gene_var, mode.prop)

```

### PCA of viral accessory genes
Principal components analysis for dimensionality reduction of binary variables.

```{r pca_sum}

#(1) libraries for PCA
library(vegan)
library(reshape2)
library(factoextra) #fviz_eig

# #(2) Subset data and reformat as numeric matrix
# genes_mat <- subset(genes,select=-c(Genome,VirusSpecies,HostGenus))
# mat <- as.matrix(genes_mat[,-1])
# rownames(mat) <- genes_mat[,1] %>% pull()
# class(mat) <- "numeric"

#(3) Apply PCA using stats::prcomp 
pca <- prcomp(genes[,5:985])      #scaling/centering not appropriate
pca_relvar <- pca$sdev^2 / sum(pca$sdev^2)
pca_relvar_per <- round(pca_relvar*100,1)

#(4) View summary results
summary(pca)
#View(pca$x) #sequence (individuals)
#View(pca$rotation) #genes (variables)

#(5) Table of importance of components: (a) Eigenvalue, (b) SD, (c) Prop of Variance, (d) Cumulative Prop
pca_importance <- as.data.frame(t(summary(pca)$importance))
pca_importance$Eigenvalue <- pca_importance$`Standard deviation`^2
pca_importance <- pca_importance %>% dplyr::relocate(Eigenvalue) 
pca_importance <- pca_importance[c(1:10),]
### Eigenvalue: the variance explained by each PC

#(6) Table of loadings ($rotation is the matrix of variable loadings where columns are eigenvectors)
pca_loadings <- as.data.frame(pca$rotation)
pca_loadings <- pca_loadings[,c(1:10)]
### Why are some loadings > |1|? Loading is the covariances/correlations b/w original vars and unit-scaled components)

#(7) Create table of accessory genes for each dimension from highest contributing to lowest
pca_AGcont <- abs(pca_loadings)
for(i in 1:ncol(pca_AGcont)){
  assign(colnames(pca_AGcont)[i], data.frame(pca_AGcont[,i]))
}

#(8) Create list of dataframes of PC loadings
list <- colnames(pca_AGcont)       
list_df = lapply(list, get)

#(9) To each dataframe in that list, add corresponding sequence data and sort in descending order (sequences with highest load value to smallest load value)
for (i in 1:length(list)) {
  colnames(list_df[[i]]) <- "Loadings"
  list_df[[i]]$Sequence <- rownames(pca_AGcont)
  list_df[[i]]=list_df[[i]][order(-list_df[[i]]$Loadings),]
}

#(10) Drop loadings (only need PC sequence rankings)
for(i in 1:length(list)) {
  list_df[[i]]$Loadings=NULL
}

#(11) Save PC sequence rankings as table 
pca_rank <- data.frame(matrix(ncol=ncol(pca_AGcont), nrow=nrow(pca_AGcont)))
colnames(pca_rank) <- colnames(pca_AGcont)
for(i in 1:length(list)) {
  pca_rank[,i] = list_df[[i]]
}
head(pca_rank,20)    

rm(list_df, list=ls(pattern="^PC"), pca_AGcont, pca_importance, pca_loadings, pca_rank, i, list) 
```

### PCA visualizations

```{r pca_viz}
#Vizualize variance: screeplots, cumulative variance, etc.
#Vizualize individuals/scores
#Vizualize variables/loadings: by virus family, etc.
#Vizualize centroid
#Visualize scores by cluster via hierarchical cluster analysis (k-means)

#(1) Vizualize variance: Screeplot of variance (eigenvalues) shows the decreasing rate at which variance is explained by additional PCs
screeplot(pca, type="lines", npcs=15, main="Scree plot of Eigenvalues for the first 10 PCs")
abline(h=1, col="red", lty=5)
legend("topright", legend=c("Eigenvalue = 1"),
       col=c("red"), lty=5, cex=1)
### suggests cutoff at PC10

#(2) Vizualize variance: Screeplot of cumulative variance (%)
screeplot <- barplot(pca_relvar_per[1:10], xlab='PC', ylab='Percentage of explained variances', main='Screeplot of explained variances', names.arg=1:10, las=1, ylim=c(0,max(pca_relvar_per)+10), col='gray')
text(screeplot, 0, y=pca_relvar_per[1:10], label=pca_relvar_per[1:10],cex=0.8, pos=3, col="red")
# fviz_eig(pca, choice=c("variance"), main = "Scree plot of explained variances") # these values agree with pca_relvar (variance explained)

#(3) Visualize variance: Cumulative variance plot
cumpro <- cumsum(pca$sdev^2 / sum(pca$sdev^2))
plot(cumpro[0:15], xlab = "Dimension", ylab = "Proportion of explained variance", main = "Cumulative variance plot")
abline(v = 10, col="blue", lty=5)
abline(h = 0.7, col="blue", lty=5)
legend("topleft", legend=c("Cut-off @ PC10"),
       col=c("blue"), lty=5, cex=1)

#(4) Visualize scores: Plots of individual sequences 
fviz_pca_ind(pca) + ggtitle("PCA Plot of Sequences")
### with ellipses
fviz_pca_ind(pca, geom.ind = "point", pointshape = 21, pointsize = 2, 
             col.ind = "black", addEllipses = TRUE, label = "var",
             col.var = "black", palette = "rickandmorty", repel = TRUE,
             alpha.ind = 0.7) +
      ggtitle("PCA Plot of Sequences") + theme(plot.title = element_text(hjust = 0.5))

#(5) Visualize scores: Plot of individual sequences by virus species
library(ggfortify)
autoplot(pca, data = genes, colour = 'VirusSpecies') + ggtitle("Plot of Sequences by Virus Species")

#(6) Visualize loading: Plot of PCA variables 1 and 2
fviz_pca_var(pca, 
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,     # Avoid text overlapping
             label = c("ind", "ind.sup", "quali", "var", "quanti.sup")) +
               ggtitle("Plot of Gene Loadings for Dimensions 1 and 2")
### Here we see PC1 has large positive associations with a number of AGs like ADZ29556.1, SNB51281.1, and AGZ01283.1 that point in the same direction as PC1. PC2 has some moderately positive associations with AGs like BDQ10560.1
### QKE61192.1 - hypothetical protein [Vaccinia virus]
### QNP13375.1 - MPXV Viral membrane assembly proteins (VMAP) (Cop-A 30.5L)"

#(7) Visualize loading: Plot of PCA variables 3 and 4
fviz_pca_var(pca, axes = c(3, 4),
             col.var = "contrib", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE) +
             ggtitle("Plot of Gene Loadings for Dimensions 3 and 4")

#(8) Visualize scores and loadings: Biplot of individuals and variables
fviz_pca_biplot(pca,
                col.var = "contrib",
                gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE) +
               ggtitle("Biplot of Sequences and Gene Loadings")

#(9) Visualize scores and loadings: Biplot of top 20 contributing inds and vars
fviz_pca_biplot(pca,
                col.var = "contrib",
                gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,
             select.ind=list(contrib=20),
             select.var=list(contrib=20),
             max.overlaps=Inf) +
             ggtitle("Biplot of Top 20 Contributing Sequences and Gene Loadings")

rm(cumpro)

```

### PCA Hierarchical Cluster Analysis
```{r pca_cluster}

#(1) H-cluster analysis: Extract coordinates for individual sequences
ind.coord <- pca$x
rownames(ind.coord) <- 1:nrow(ind.coord)
db <- cbind(genes$VirusSpecies, ind.coord)

#(2) H-cluster analysis: {stats} HCA on a set of dissimilarities for objects being clustered, wherein each object is assigned its own cluster iteratively, at each stage joining the 2 most similar clusters (bottom-up dendogram until only one cluster left). 
clusters <- hclust(dist(db[,2:3]))
plot(clusters)
abline(h = 8, col="red", lty=5)
abline(h = 4, col="blue", lty=5)

#(3) H-cluster analysis: Cluster cut
clusterCut <- cutree(clusters, 6)
table(clusterCut)

#(4) H-cluster analysis: Prop tables by virus species
mytable<-table(clusterCut, genes$VirusSpecies)
mytable2 <- data.frame(prop.table(mytable,2))
ggplot(mytable2, aes(x = Var2, y = Freq, fill = clusterCut)) +
  geom_col() +
  labs(fill='Cluster') +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle=45,hjust=1)) +
  ggtitle("Distribution by Virus Species")

#(5) H-cluster analysis: Re-run PCA to color by cluster  
  #add cluster to original db
  genes2<-data.frame(cbind(genes,clusterCut))
  genes2$clusterCut <- as.factor(genes2$clusterCut)

#(14) Run PCA as before, but now grouping by cluster
pca2 <- prcomp(genes2[,5:985])      #scaling/centering not appropriate
# pca_relvar <- pca$sdev^2 / sum(pca$sdev^2)
# pca_relvar_per <- round(pca_relvar*100,1)

fviz_pca_ind(pca2, geom.ind = "point", pointshape = 21, 
             pointsize = 2, 
             fill.ind = genes2$clusterCut, 
             col.ind = "black", 
             addEllipses = TRUE,
             label = "var",
             col.var = "black",
             palette = "rickandmorty",
             repel = TRUE,
             legend.title = "Cluster",
             alpha.ind = 0.5) +
  ggtitle("PCA Plot of Sequences by Cluster") +
  theme(plot.title = element_text(hjust = 0.5))

fviz_pca_biplot(pca2, geom.ind = "point", pointshape = 21, 
             pointsize = 2, 
             fill.ind = genes2$clusterCut,
             col.ind = "black",
             label = "var",
             repel = TRUE,
             legend.title = "Cluster",
             addEllipses = TRUE,
             pallete = "lancet",
             alpha.ind = 0,
             col.var = "grey40") +
    ggtitle("PCA Biplot of Sequences and Gene Loadings by Cluster")

db.vf <- dplyr::select(genes2, Sequence, clusterCut)
# write.csv(db.vf,"clusters.csv", row.names = F)

#() Clean environment
rm(clusters, db, db.vf, genes2, ind.coord, pca, pca2, clusterCut)

```

### Non-Negative Matrix Factorization

PCA vs. NMF

PCA: Goal is to reduce dimensionality while maintaining maximal variance
- Each principal component (PC) is linear combination of uncorrelated attributes/features
- Number of principal components is limited by the number of samples using the eigenvalue decomposition method (?) 

NMF: Like PCA except coefficients in the linear combination (weight of each base) must be non-negative
- Explains the dataset through factoring into two non-negative matrices in such a way that the distance between the original matrix and subset matrices are minimized
- Update rule implemented by NMF algorithms are multiplicative instead of additive - multiplicative update rules can hold nonnegativity easily with nonnegativity initalization
- The number of learned basis experiments is not as limited by number of samples
- NMF is stochastic (PCA is deterministic)
- Can be much more stable and well-specified reconstruction when
assumptions are appropriate
- Excellent for separating out additive factors

```{r pca_alt}

#() Resources: https://rpubs.com/JanpuHou/300168; https://aarmey.github.io/ml-for-bioe/public/Wk4-Lecture7.pdf
#() Load packages
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("Biobase", version = "3.16")
library(Biobase)
library(NMF)

#() Run NMF defaulting to 'brunet' algorithm and 'random' seed on initialization
genes_mat <- subset(genes,select=-c(Genome,VirusSpecies,HostGenus))
mat <- as.matrix(genes_mat[,-1])
rownames(mat) <- genes_mat[,1] %>% pull()
class(mat) <- "numeric"

start_time <- Sys.time()
# nmf <- nmf(genes[,5:10], 6, "brunet") #Time difference of 0.2662811 secs
nmf <- nmf(genes[,5:100], 96, "brunet") #Time difference of 17.2904 secs
end_time <- Sys.time()
end_time - start_time

# Summarize results
nmf #explore object
fit(nmf) #retrieve fitted model
V.hat <- fitted(nmf) #retrieve estimated target matrix and its dimensions
dim(V.hat)
summary(nmf)

# Perform multiple runs to achieve stability because the seeding method is stochastic (random): the returned object only contains the best fit over all the runs (i.e., the factorization that achieved the lowest approximation error)
start_time <- Sys.time()
nmf_multi <- nmf(genes[,5:100], 96, nrun=5, .opt='v') #.opt='v' tries to run in parallel using all cores
end_time <- Sys.time()
end_time - start_time #Time difference of 25.05052 secs

# NMF Visualizations
nmf <- nmf(genes[,5:100], 95, .opt='t')
plot(nmf)
NMFscores <- nmf_multi@fit@W
NMFloadings <- nmf_multi@fit@H

plot(NMFscores[,1:2],  # x and y data
     pch=21,           # point shape
     cex=1.5,          # point size
     main="Scores"     # title of plot
)
plot(NMFloadings[,1:2],   # x and y data
     pch=21,              # point shape
     bg="black",          # point color
     cex=1,               # point size
     main="Loadings"      # title of plot
)

```


### PCA of viral accessory genes excluding outliers
Principal components analysis for dimensionality reduction of binary variables, excluding outliers.

```{r prep_pca}

#(1) Let's see what happens when we remove outliers identified in the previous biplot
genes_in <- genes[!grepl("MT724769_1|MN346703_1|MT724770_1|DQ011155_1", genes$Genome),]

genes_out <- genes[grepl("MT724769_1|MN346703_1|MT724770_1|DQ011155_1", genes$Genome),]

#(2) Subset data and reformat as numeric matrix
genes_in_mat <- subset(genes_in,select=-c(Genome,VirusSpecies,HostGenus))
mat_in <- as.matrix(genes_in_mat[,-1])
rownames(mat_in) <- genes_in_mat[,1] %>% pull()
class(mat_in) <- "numeric"

genes_out_mat <- subset(genes_out,select=-c(Genome,VirusSpecies,HostGenus))
mat_out <- as.matrix(genes_out_mat[,-1])
rownames(mat_out) <- genes_out_mat[,1] %>% pull()
class(mat_out) <- "numeric"

#(3) Apply PCA using stats::prcomp
pca_in <- prcomp(mat_in)
pca_in_relvar <- pca_in$sdev^2 / sum(pca_in$sdev^2)
pca_in_relvar_per <- round(pca_in_relvar*100,1)

#(4) Prediction of PCs for outliers
pred <- predict(pca_in, newdata=mat_out)
pca_pred <- pca_in
pca_pred$x <- rbind(pca_pred$x, pred)

#(5) Plot of individuals w/ outliers in shaded bullets
COLOR <- c(1:length(unique(genes$VirusSpecies)))
PCH <- c(1,16)
pc <- c(1,2) # principal components to plot
plot(pca_in$x[,pc], cex=PCH[1],
     xlab=paste0("PC ", pc[1], " (", pca_in_relvar_per[pc[1]], "%)"),
     ylab=paste0("PC ", pc[2], " (", pca_in_relvar_per[pc[2]], "%)")
)
points(pred[,pc], pch=PCH[2]) + abline(h = 0, v=0, lty = 2) +
title("2D PCA-plot") + theme(plot.title = element_text(hjust = 0.5))

#(6) Plot of individuals w/ all unshaded bullets
fviz_pca_ind(pca_pred, geom.ind = "point", pointshape = 21, pointsize = 2,
             col.ind = "black", addEllipses = F, label = "var",
             col.var = "black", palette = "rickandmorty", repel = TRUE,
             alpha.ind = 0.7)+
      ggtitle("2D PCA-plot") + theme(plot.title = element_text(hjust = 0.5))

#(13) Biplot of individuals and variables
fviz_pca_biplot(pca_pred,
                col.var = "contrib",
                gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE
             )

#(14) Biplot of top 20 contributing individuals and variables
fviz_pca_biplot(pca_pred,
                col.var = "contrib",
                gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,
             select.ind=list(contrib=20),
             select.var=list(contrib=20)
             )

#(15) Clean environment
rm(list=setdiff(ls(), "genes"))

```

### MCA of viral accessory genes
Multiple Correspondence Analysis (MCA) for dimension reduction of categorical variables.

```{r prep_mca}

#(1) libraries for MCA
library(FactoMineR)
library(vegan)
library(dplyr)
library(reshape2)
library(factoextra) #fviz_eig

#(2) Subset data and reformat gene variables as factor
###Note: Actual data for MCA is pending. For the purposes of this exercise, I am manipulating the presence/absence of OPV gene data from binary variables to factor variables
genes_cat <- subset(genes,select=-c(Genome,VirusSpecies,HostGenus))
genes_cat[] <- lapply(genes_cat, as.character)
rownames <- genes$Sequence
genes_cat[,-1] <- lapply(genes_cat[,-1], factor)
genes_cat$Sequence=NULL
rownames(genes_cat) <- rownames
#str(genes_cat)


#(3) Apply MCA using FactoMineR::MCA
mca = MCA(genes_cat, graph = FALSE)
# pca_relvar <- pca$sdev^2 / sum(pca$sdev^2)
# pca_relvar_per <- round(pca_relvar*100,1)

#(4) List and summarize MCA results
print(mca)
summary(mca)
head(mca$ind$coord) #sequence (individuals)
head(mca$var$coord) #genes (variables)

#(5) Screeplot - Variance (Eigenvalues)
#mca$eig
fviz_eig(mca, addlabels = TRUE, ylim = c(0, 25))

#(6) Plots of individuals
fviz_mca_ind(mca, repel=TRUE)

#(7) Plot of MCA variables 1 and 2
fviz_mca_var(mca, repel = TRUE) ##

#(8) Biplot
fviz_mca_biplot(mca, repel = TRUE)
fviz_mca_biplot(mca, repel = FALSE, select.ind=list(contrib=20), select.var=list(contrib=20))

##### TO BE CONTINUED - we can build on the MCA and FAMD analysis once data is ready #####

#() Clean environment
rm(genes,genes_cat,genes_mat,genes_tax,mat,mca,pc_cutoff)

```
